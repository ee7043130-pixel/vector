<!DOCTYPE html>
<html lang="ja">
<head>
  <link rel="stylesheet" href="vector.css">
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=no" />
<title>ãƒ™ã‚¯ãƒˆãƒ«å­¦ç¿’</title>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/webxr/VRButton.js"></script>
</head>
<body>

<button id="showInfo" class="show-panel-btn" style="display:none;"></button>
<button id="showControls" class="show-panel-btn" style="display:none;"></button>

<div id="learningBox">
  <div class="learning-section">
    <div class="learning-header">
      <h4>ğŸ“– å­¦ç¿’ãƒã‚¤ãƒ³ãƒˆ</h4>
      <button class="toggle-learning">âœ–</button>
    </div>
    <div class="learning-content">
      <div class="learn-item">å†…ç©ã‚’"ãƒ»" å¤–ç©ã‚’"Ã—"ã§è¡¨ã™</div>
      <div class="learn-item"><strong>å†…ç© :</strong> å‘ãã®è¿‘ã•</div>

      <div class="learn-item"><strong>|ã€‡Â·â–³|:</strong> å†…ç©ã®çµ¶å¯¾å€¤</div>
      <div class="learn-item"><strong>å¤–ç© :</strong> 2ãƒ™ã‚¯ãƒˆãƒ«ãŒä½œã‚‹å¹³è¡Œå››è¾ºå½¢ã®é¢ç©</div>
      <div class="learn-item"><strong>|ã€‡|:</strong> ãƒ™ã‚¯ãƒˆãƒ«ã®å¤§ãã•(é•·ã•)</div>
      <div class="learn-item" style="margin-top: 8px;">
        <span class="detail-toggle-link" id="toggleDetailBtn"> ã‚‚ã£ã¨è©³ã—ã â‰«</span>
      </div>
    </div>
    <div class="detail-section" id="detailSection">
      <div class="detail-content">
        <h5> å†…ç©(ãƒ‰ãƒƒãƒˆç©)</h5>
        <p><strong>å®šç¾©:</strong> AÂ·B = |A||B|cosÎ¸</p>
        <p><strong>åº§æ¨™è¨ˆç®—:</strong> AÂ·B = AxBx + AyBy + AzBz</p>
        <p><strong>â­æ„å‘³:</strong></p>
        <ul>
          <li>2ã¤ã®ãƒ™ã‚¯ãƒˆãƒ«ã®å‘ãã®è¿‘ã•</li>
          <li>å†…ç©ãŒæ­£ï¼šé‹­è§’(0Â°ï¼œğœƒï¼œ90Â°)	 </li>
          <li>å†…ç©ãŒ0  ï¼šå‚ç›´(ğœƒï¼90Â°)</li>
          <li>å†…ç©ãŒè² ï¼šéˆè§’(90Â°ï¼œğœƒï¼œ180Â°)</li>
          <li>å¹³è¡Œ(åŒã˜å‘ã) â†’ Î˜ï¼0Â°</li>
          <li>å¹³è¡Œ(é€†å‘ã) â†’ Î˜ï¼180Â°</li>
        </ul>
        <p><strong>æ€§è³ª:</strong></p>
         <ul>
          <li>aãƒ»aâ‰§0</li>
          <li>aãƒ»aï¼0ã¨ãªã‚‹ã®ã¯aï¼0ã®ã¨ãã«é™ã‚‹</li>
          <li>aãƒ»b=bãƒ»a</li>
        </ul>
       
        
        <h5> å¤–ç©(ã‚¯ãƒ­ã‚¹ç©)</h5>
        <p><strong>å®šç¾©:</strong> |AÃ—B| = |A||B|sinÎ¸</p>
        <p><strong>åº§æ¨™è¨ˆç®—:</strong></p>
        <p>AÃ—B = (AyBz-AzBy, AzBx-AxBz, AxBy-AyBx)</p>
        <p><strong>â­æ„å‘³:</strong></p>
        <ul>
          <li>2ã¤ã®ãƒ™ã‚¯ãƒˆãƒ«ãŒä½œã‚‹å¹³è¡Œå››è¾ºå½¢ã®é¢ç©</li>
          <li>2ã¤ã®ãƒ™ã‚¯ãƒˆãƒ«ã«å‚ç›´ãªãƒ™ã‚¯ãƒˆãƒ«</li>
          <li>å¹³è¡Œ(é€†å¹³è¡Œ) â†’ 0 </li>
          <li>å‚ç›´(ç›´äº¤) â†’ æœ€å¤§(90Â°)</li>
          <p></p>
          <p>å³æ‰‹ã®æ³•å‰‡ã§æ–¹å‘ãŒæ±ºã¾ã‚‹</p>
          <p>A(äººå·®ã—æŒ‡),B(ä¸­æŒ‡),å¤–ç©(è¦ªæŒ‡)ã€€</p> 
        </ul>

        <h5> å˜ä½ãƒ™ã‚¯ãƒˆãƒ«</h5>
        <p><strong>â­æ„å‘³:</strong></p>
        <ul>
          <li>é•·ã•ãŒï¼‘ã®ãƒ™ã‚¯ãƒˆãƒ«</li>
          <p>eâ‚ï¼(1,0,0)</p>
          <p>eâ‚‚ï¼(0,1,0)</p>
          <p>eâ‚ƒï¼(0,0,1)</p>
          
        </ul>

        <h5>â­ã¾ã¨ã‚,point</h5> 
        <ul>
          <li> å†…ç©ã¯è§’åº¦ãŒå°ã•ã„ã»ã©å¤§ãããªã‚‹</li>
          <li> å¤–ç©ã¯é•·ã•ãŒé•·ã„ã»ã©å¤§ãããªã‚‹</li>
        </ul>
  
        
        <h5> è§’åº¦ã¨ãƒ™ã‚¯ãƒˆãƒ«ã®å¤§ãã•</h5>
        <p><strong>ãƒ™ã‚¯ãƒˆãƒ«ã®å¤§ãã•:</strong> |A| = âˆš(AxÂ² + AyÂ² + AzÂ²)</p>
        <p><strong>è§’åº¦ã®è¨ˆç®—:</strong> cosÎ¸ = (AÂ·B) / (|A||B|)</p>
        <p><strong>é–¢ä¿‚å¼:</strong></p>
        <ul>
          <li>å†…ç©ã¨å¤–ç©: (AÂ·B)Â² + |AÃ—B|Â² = |A|Â²|B|Â²</li>
          <li>å¹³è¡Œ: AÃ—B = 0</li>
          <li>å‚ç›´: AÂ·B = 0</li>
        </ul>
      </div>
    </div>
  </div>
</div>

<div id="info">
  <div class="box-header">
    <h3>ğŸ§® 3Dãƒ™ã‚¯ãƒˆãƒ«</h3>
   <button class="toggle-box">âœ–</button>
  </div>
  <hr style="border-color: #444; margin: 10px 0;">
   <div class="calc-row">
    <span class="calc-label">AÂ·B (å†…ç©):</span>
    <span class="calc-value" id="dotProductAB">0.00</span>
  </div>
  <div class="calc-row">
    <span class="calc-label">AÂ·C (å†…ç©):</span>
    <span class="calc-value" id="dotProductAC">0.00</span>
  </div>
  <div class="calc-row">
    <span class="calc-label">BÂ·C (å†…ç©):</span>
    <span class="calc-value" id="dotProductBC">0.00</span>
  </div>
  <hr style="border-color: #444; margin: 10px 0;">
  <div class="calc-row">
    <span class="calc-label">|AÂ·B|:</span>
    <span class="calc-value" id="dotMagnitudeAB">0.00</span>
  </div>
  <div class="calc-row">
    <span class="calc-label">|AÂ·C|:</span>
    <span class="calc-value" id="dotMagnitudeAC">0.00</span>
  </div>
  <div class="calc-row">
    <span class="calc-label">|BÂ·C|:</span>
    <span class="calc-value" id="dotMagnitudeBC">0.00</span>
  </div>
  <hr style="border-color: #444; margin: 10px 0;">
   <div class="calc-row">
  <span class="calc-label">AÃ—B (å¤–ç©):</span>
  <span class="calc-value" id="crossVectorAB">0.00</span>
</div>
<div class="calc-row">
  <span class="calc-label">AÃ—C (å¤–ç©):</span>
  <span class="calc-value" id="crossVectorAC">0.00</span>
</div>
<div class="calc-row">
  <span class="calc-label">BÃ—C (å¤–ç©):</span>
  <span class="calc-value" id="crossVectorBC">0.00</span>
</div>
  <hr style="border-color: #444; margin: 10px 0;">
  <div class="calc-row">
    <span class="calc-label">|AÃ—B|:</span>
    <span class="calc-value" id="crossProductAB">0.00</span>
  </div>
  <div class="calc-row">
    <span class="calc-label">|AÃ—C|:</span>
    <span class="calc-value" id="crossProductAC">0.00</span>
  </div>
  <div class="calc-row">
    <span class="calc-label">|BÃ—C|:</span>
    <span class="calc-value" id="crossProductBC">0.00</span>
  </div>
  <hr style="border-color: #444; margin: 10px 0;">
  <div class="calc-row">
    <span class="calc-label">|A|:</span>
    <span class="calc-value" id="magnitudeA">0.00</span>
  </div>
  <div class="calc-row">
    <span class="calc-label">|B|:</span>
    <span class="calc-value" id="magnitudeB">0.00</span>
  </div>
  <div class="calc-row">
    <span class="calc-label">|C|:</span>
    <span class="calc-value" id="magnitudeC">0.00</span>
  </div>
  <hr style="border-color: #444; margin: 10px 0;">
  <div class="calc-row">
    <span class="calc-label">âˆ (A,B):</span>
    <span class="calc-value" id="angleAB">0.0Â°</span>
  </div>
  <div class="calc-row">
    <span class="calc-label">âˆ (A,C):</span>
    <span class="calc-value" id="angleAC">0.0Â°</span>
  </div>
  <div class="calc-row">
    <span class="calc-label">âˆ (B,C):</span>
    <span class="calc-value" id="angleBC">0.0Â°</span>
  </div>
  <div class="vr-info" id="vrInfo" style="display:none;">
      ğŸ¥½ VRãƒ¢ãƒ¼ãƒ‰èµ·å‹•ä¸­
  </div>
</div>

<div id="dotProductGraph">
  <div class="graph-resize-handle"></div>
  <canvas id="graphCanvas" width="200" height="150"></canvas>
</div>

<div id="unitCircleGraph">
  <div class="graph-resize-handle"></div>
  <canvas id="unitCircleCanvas" width="180" height="180"></canvas>
</div>

<div id="controls">
  <div class="resize-handle"></div>
  <div class="box-header">
     <h3>æ“ä½œãƒ‘ãƒãƒ«</h3>
    <button class="toggle-box">âœ–</button>
  </div>
  <h4>
    <input type="checkbox" id="toggleVectorA" checked style="margin-right: 8px; cursor: pointer; width: 18px; height: 18px; vertical-align: middle;">
    ãƒ™ã‚¯ãƒˆãƒ« A (é’)
  </h4>
  <div class="slider-container">
    <label>X: <input type="number" class="value-input" id="vectorAX-value" value="3.0" min="-10" max="10" step="0.1"></label>
    <input type="range" id="vectorAX" min="-10" max="10" step="0.1" value="3" />
  </div>
  <div class="slider-container">
    <label>Y: <input type="number" class="value-input" id="vectorAY-value" value="2.0" min="-10" max="10" step="0.1"></label>
    <input type="range" id="vectorAY" min="-10" max="10" step="0.1" value="2" />
  </div>
  <div class="slider-container">
    <label>Z: <input type="number" class="value-input" id="vectorAZ-value" value="1.0" min="-10" max="10" step="0.1"></label>
    <input type="range" id="vectorAZ" min="-10" max="10" step="0.1" value="1" />
  </div>

  <h4>
    <input type="checkbox" id="toggleVectorB" checked style="margin-right: 8px; cursor: pointer; width: 18px; height: 18px; vertical-align: middle;">
   ãƒ™ã‚¯ãƒˆãƒ« B (èµ¤)
  </h4>
  <div class="slider-container">
    <label>X: <input type="number" class="value-input red" id="vectorBX-value" value="2.0" min="-10" max="10" step="0.1"></label>
    <input type="range" id="vectorBX" min="-10" max="10" step="0.1" value="2" />
  </div>
  <div class="slider-container">
    <label>Y: <input type="number" class="value-input red" id="vectorBY-value" value="3.0" min="-10" max="10" step="0.1"></label>
    <input type="range" id="vectorBY" min="-10" max="10" step="0.1" value="3" />
  </div>
  <div class="slider-container">
    <label>Z: <input type="number" class="value-input red" id="vectorBZ-value" value="0.5" min="-10" max="10" step="0.1"></label>
    <input type="range" id="vectorBZ" min="-10" max="10" step="0.1" value="0.5" />
  </div>

  <h4>
    <input type="checkbox" id="toggleVectorC" checked style="margin-right: 8px; cursor: pointer; width: 18px; height: 18px; vertical-align: middle;">
    ãƒ™ã‚¯ãƒˆãƒ« C (ç·‘)
  </h4>
  <div class="slider-container">
    <label>X: <input type="number" class="value-input green" id="vectorCX-value" value="1.0" min="-10" max="10" step="0.1"></label>
    <input type="range" id="vectorCX" min="-10" max="10" step="0.1" value="1" />
  </div>
  <div class="slider-container">
    <label>Y: <input type="number" class="value-input green" id="vectorCY-value" value="1.0" min="-10" max="10" step="0.1"></label>
    <input type="range" id="vectorCY" min="-10" max="10" step="0.1" value="1" />
  </div>
  <div class="slider-container">
    <label>Z: <input type="number" class="value-input green" id="vectorCZ-value" value="3.0" min="-10" max="10" step="0.1"></label>
    <input type="range" id="vectorCZ" min="-10" max="10" step="0.1" value="3" />
  </div>

  <button id="togglePlaneBtn">å¹³é¢ON/OFF</button>
  <button id="toggleGraphBtn">ã‚°ãƒ©ãƒ•ON/OFF</button>
  <button id="toggleCrossBtn">å¤–ç©ON/OFF</button>
  <button id="toggleGridBtn">ã‚°ãƒªãƒƒãƒ‰ç·šON/OFF</button>
  <button id="resetBtn">ãƒªã‚»ãƒƒãƒˆ</button>
  <button id="module">VR</button>

</div>

<script>
  let scene, camera, renderer, controls;
  let vectorAArrow, vectorBArrow, vectorCArrow;
  let vectorALabel, vectorBLabel, vectorCLabel;
  let crossProductABArrow, crossProductACArrow, crossProductBCArrow;
  let crossProductABLabel, crossProductACLabel, crossProductBCLabel;
  
  let angleLabels = [];
  let angleArcs = [];
  let projectionLines = [];
  let grid, parallelogram;
  let transformControl;
  let isVRMode = false;

  let isDraggingVector = false;
  let draggedVector = null;
  let dragPlane = new THREE.Plane();
  let dragOffset = new THREE.Vector3();
  
  let vecA = new THREE.Vector3(3, 2, 1);
  let vecB = new THREE.Vector3(2, 3, 0.5);
  let vecC = new THREE.Vector3(1, 1, 3);

  let controllerGrip1, controllerGrip2;

  function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a15);

    camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(20, 20, 20);
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 0, 0);
    controls.enableDamping = false;
    controls.minDistance = 3;
    controls.maxDistance = 50;
    controls.enablePan = true;

    controls.mouseButtons = {
  LEFT: THREE.MOUSE.ROTATE,
  MIDDLE: THREE.MOUSE.PAN,
  RIGHT: THREE.MOUSE.PAN
};

controls.touches = {
  ONE: THREE.TOUCH.ROTATE,
  TWO: THREE.TOUCH.DOLLY_PAN
};

renderer.domElement.addEventListener('touchstart', (e) => {
  e.stopPropagation();
}, { passive: false });
renderer.domElement.addEventListener('touchmove', (e) => {
  e.stopPropagation();
}, { passive: false });


    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 10, 10);
    scene.add(directionalLight);

    // VRç”¨ã®3D UIãƒ‘ãƒãƒ«ã‚’ä½œæˆ
function createvrUIPanel() {
 const canvas = document.createElement('canvas');
 canvas.width = 500;
 canvas.height = 500;
 const ctx = canvas.getContext('2d');
 // èƒŒæ™¯
 ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
 ctx.fillRect(0, 0, 1024, 1024);
 // ã‚¿ã‚¤ãƒˆãƒ«
 ctx.fillStyle = '#0cf';
 ctx.font = 'bold 48px Arial';
 ctx.fillText('ğŸ“– ãƒ™ã‚¯ãƒˆãƒ«å­¦ç¿’', 50, 80);
 // å†…å®¹
 ctx.fillStyle = '#ddd';
 ctx.font = '32px Arial';
 let y = 150;
 const lines = [
   'å†…ç©ã‚’"ãƒ»" å¤–ç©ã‚’"Ã—"ã§è¡¨ã™',
   '',
   'å†…ç©: å‘ãã®è¿‘ã•',
   'å¤–ç©: å¹³è¡Œå››è¾ºå½¢ã®é¢ç©',
   '|ã€‡|: ãƒ™ã‚¯ãƒˆãƒ«ã®å¤§ãã•',
   '',
   'æ“ä½œæ–¹æ³•:',
   'ãƒ»ãƒˆãƒªã‚¬ãƒ¼: çŸ¢å°ã‚’æ´ã‚€',
   'ãƒ»ã‚¹ãƒ†ã‚£ãƒƒã‚¯: ç§»å‹•'
 ];
 lines.forEach(line => {
   ctx.fillText(line, 50, y);
   y += 45;
 });
 // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¨ã—ã¦ä½¿ç”¨
 const texture = new THREE.CanvasTexture(canvas);
 const material = new THREE.MeshBasicMaterial({
   map: texture,
   transparent: true,
   side: THREE.DoubleSide
 });
 const geometry = new THREE.PlaneGeometry(3, 3);
 const mesh = new THREE.Mesh(geometry, material);
 // ãƒ‘ãƒãƒ«ã‚’ã‚«ãƒ¡ãƒ©ã®å·¦å´ã«é…ç½®
 mesh.position.set(-8, 3, -6);
 mesh.rotation.y = -Math.PI / 6; // å°‘ã—å†…å´ã‚’å‘ã‘ã‚‹
 return mesh;
}
// VRç”¨ã®è¨ˆç®—çµæœãƒ‘ãƒãƒ«ã‚’ä½œæˆ
function createVRCalcPanel() {
 const canvas = document.createElement('canvas');
 canvas.width = 512;
 canvas.height = 768;
 const ctx = canvas.getContext('2d');
 // èƒŒæ™¯
 ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
 ctx.fillRect(0, 0, 512, 768);
 // ã‚¿ã‚¤ãƒˆãƒ«
 ctx.fillStyle = '#0cf';
 ctx.font = 'bold 36px Arial';
 ctx.fillText('ğŸ§® è¨ˆç®—çµæœ', 30, 50);
 const texture = new THREE.CanvasTexture(canvas);
 const material = new THREE.MeshBasicMaterial({
   map: texture,
   transparent: true,
   side: THREE.DoubleSide
 });
 const geometry = new THREE.PlaneGeometry(2, 3);
 const mesh = new THREE.Mesh(geometry, material);
 // ãƒ‘ãƒãƒ«ã‚’ã‚«ãƒ¡ãƒ©ã®å³å´ã«é…ç½®
 mesh.position.set(80, 30 ,-60);
 mesh.rotation.y = -Math.PI / 6;
 return mesh;
}
// VRè¨ˆç®—ãƒ‘ãƒãƒ«ã‚’æ›´æ–°
function updateVRCalcPanel(mesh) {
 const canvas = document.createElement('canvas');
 canvas.width = 512;
 canvas.height = 768;
 const ctx = canvas.getContext('2d');
 ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
 ctx.fillRect(0, 0, 512, 768);
 ctx.fillStyle = '#0cf';
 ctx.font = 'bold 36px Arial';
 ctx.fillText('ğŸ§® è¨ˆç®—çµæœ', 30, 50);
 ctx.fillStyle = '#ddd';
 ctx.font = '28px Arial';
 let y = 120;
 const dotAB = vecA.dot(vecB).toFixed(2);
 const magA = vecA.length().toFixed(2);
 const magB = vecB.length().toFixed(2);
 const magC = vecC.length().toFixed(2);
 const calcAngle = (v1, v2) => {
   const m1 = v1.length();
   const m2 = v2.length();
   if(m1 < 0.001 || m2 < 0.001) return 0;
   const cosAngle = v1.dot(v2) / (m1 * m2);
   return (Math.acos(Math.max(-1, Math.min(1, cosAngle))) * 180 / Math.PI).toFixed(1);
 };
 const angleAB = calcAngle(vecA, vecB);
 const lines = [
   `AÂ·B: ${dotAB}`,
   '',
   `|A|: ${magA}`,
   `|B|: ${magB}`,
   `|C|: ${magC}`,
   '',
   `âˆ (A,B): ${angleAB}Â°`
 ];
 lines.forEach(line => {
   ctx.fillText(line, 30, y);
   y += 50;
 });
 mesh.material.map.dispose();
 mesh.material.map = new THREE.CanvasTexture(canvas);
 mesh.material.needsUpdate = true;
}

    setupVRControllers();
    createGrid();
    createVectorArrows();
    createCrossProductArrows();
    createProjectionLines();
    createParallelogram();
    createAngleArcs();
    createTransformControls();
    setupSliderControls();
    setupDirectArrowDragging();
    updateAllVectors();
    
    setTimeout(adjustPanelPositions, 100);

    window.addEventListener('resize', onWindowResize);
    renderer.setAnimationLoop(animate);
  }
//çŸ¢å°ã®ãƒ‰ãƒ©ãƒƒã‚°
 function setupDirectArrowDragging() {
  renderer.domElement.addEventListener('pointerdown', (event) => {
    const mouse = new THREE.Vector2();
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);

    const arrows = [vectorAArrow, vectorBArrow, vectorCArrow];
    const helpers = arrows.map(arrow => arrow.userData.helper).filter(h => h);
    const allObjects = [...arrows, ...helpers];
    
    const intersects = raycaster.intersectObjects(allObjects, true);

    if(intersects.length > 0){
      let obj = intersects[0].object;
      let targetHelper = null;

      if(obj.userData.isHelper){
        targetHelper = obj;
      } else {
        while(obj.parent && !obj.userData.isArrow){
          obj = obj.parent;
        }
        if(obj.userData.isArrow && obj.userData.helper){
          targetHelper = obj.userData.helper;
        }
      }

      if(targetHelper){
        // å·¦ã‚¯ãƒªãƒƒã‚¯ï¼šTransformControlã‚’ä½¿ç”¨
        if(event.button === 0) {
          controls.enabled = false;
          transformControl.attach(targetHelper);
          transformControl.visible = true;
          controls.target.set(0, 0, 0);
          controls.update();
          event.stopPropagation();
        }
        // ä¸­ã‚¯ãƒªãƒƒã‚¯ï¼šç›´æ¥ç§»å‹•
        else if(event.button === 1) {
          event.preventDefault();
          event.stopPropagation();
          isDraggingVector = true;
          draggedVector = targetHelper;
          controls.enabled = false;
          
          // ã‚«ãƒ¡ãƒ©æ–¹å‘ã«å‚ç›´ãªå¹³é¢ã‚’ä½œæˆ
          const cameraDirection = new THREE.Vector3();
          camera.getWorldDirection(cameraDirection);
          dragPlane.setFromNormalAndCoplanarPoint(cameraDirection, targetHelper.position);
          
          // äº¤ç‚¹ã‚’è¨ˆç®—
          const intersection = new THREE.Vector3();
          raycaster.ray.intersectPlane(dragPlane, intersection);
          dragOffset.copy(intersection).sub(targetHelper.position);
        }
      }
    } else {
      if(!transformControl.dragging && event.button === 0){
        transformControl.detach();
        transformControl.visible = false;
        controls.enabled = true;
        controls.target.set(0, 0, 0);
        controls.update();
      }
    }
  });

  // mousemoveã‚¤ãƒ™ãƒ³ãƒˆã®è¿½åŠ 
  renderer.domElement.addEventListener('pointermove', (event) => {
    if(isDraggingVector && draggedVector) {
      event.preventDefault();
      
      const mouse = new THREE.Vector2();
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);
      
      const intersection = new THREE.Vector3();
      if(raycaster.ray.intersectPlane(dragPlane, intersection)) {
        const newPosition = intersection.sub(dragOffset);
        draggedVector.position.copy(newPosition);
        
        const name = draggedVector.userData.vectorName;
        if(name === 'A'){
          vecA.copy(newPosition);
          updateSliderFromVector('A', vecA);
        } else if(name === 'B'){
          vecB.copy(newPosition);
          updateSliderFromVector('B', vecB);
        } else if(name === 'C'){
          vecC.copy(newPosition);
          updateSliderFromVector('C', vecC);
        }
        updateAllVectors();
      }
    }
  });

  // mouseupã‚¤ãƒ™ãƒ³ãƒˆã®è¿½åŠ 
  renderer.domElement.addEventListener('pointerup', (event) => {
    if(event.button === 1 && isDraggingVector) {
      isDraggingVector = false;
      draggedVector = null;
      controls.enabled = true;
      controls.target.set(0, 0, 0);
      controls.update();
    }
  });
}

  function setupVRControllers() {
    //VRé–‹å§‹æ™‚ã®ã‚«ãƒ¡ãƒ©ä½ç½®èª¿æ•´
    renderer.xr.addEventListener('sessionstart', () => {
    isVRMode=true;

   camera.position.set(50,30,50);  // ã‚ˆã‚Šé ãã«é…ç½®
   camera.lookAt(0, 0, 0);

   vrUIPanel = createvrUIPanel();
   scene.add(vrUIPanel);

   vrCalcPanel = createVRCalcPanel();
   scene.add(vrCalcPanel);

    //UIãƒ‘ãƒãƒ«ã‚’VRå†…ã«è¡¨ç¤º
   document.getElementById('vrInfo').style.display = 'block';
    });

   renderer.xr.addEventListener('sessionend', () => {
    isVRMode=false;

    // VRç”¨UIãƒ‘ãƒãƒ«ã‚’å‰Šé™¤
   if(vrUIPanel) {
     scene.remove(vrUIPanel);
     vrUIPanel = null;
   }
   if(vrCalcPanel) {
     scene.remove(vrCalcPanel);
     vrCalcPanel = null;
   }

    document.getElementById('vrInfo').style.display = 'none';
    });

    controller1 = renderer.xr.getController(0);
    controller1.addEventListener('selectstart', onSelectStart);
    controller1.addEventListener('selectend', onSelectEnd);
    scene.add(controller1);

    controller2 = renderer.xr.getController(1);
    controller2.addEventListener('selectstart', onSelectStart);
    controller2.addEventListener('selectend', onSelectEnd);
    scene.add(controller2);

    controllerGrip1 = renderer.xr.getControllerGrip(0);
    scene.add(controllerGrip1);

    controllerGrip2 = renderer.xr.getControllerGrip(1);
    scene.add(controllerGrip2);

    const geometry = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, 0, 0),
      new THREE.Vector3(0, 0, -1)
    ]);

    const lineMaterial = new THREE.LineBasicMaterial({color: 0xffffff});
    const line1 = new THREE.Line(geometry, lineMaterial);
    line1.scale.z = 5;
    controller1.add(line1);

    const line2 = new THREE.Line(geometry.clone(), lineMaterial.clone());
    line2.scale.z = 5;
    controller2.add(line2);
  }

  function onSelectStart(event) {
    const controller = event.target;
    const tempMatrix = new THREE.Matrix4();
    tempMatrix.identity().extractRotation(controller.matrixWorld);

    const raycaster = new THREE.Raycaster();
    raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
    raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

    const arrows = [vectorAArrow, vectorBArrow, vectorCArrow];
    const intersects = raycaster.intersectObjects(arrows, true);

    if(intersects.length > 0) {
      let obj = intersects[0].object;
      while(obj.parent && !obj.userData.isArrow){
        obj = obj.parent;
      }
      if(obj.userData.isArrow){
        controller.userData.selected = obj;
        controller.userData.vectorName = obj.userData.vectorName;
      }
    }
  }

  function onSelectEnd(event) {
    const controller = event.target;
    controller.userData.selected = undefined;
    controller.userData.vectorName = undefined;
  }

  function updateVRControllers() {
    [controller1, controller2].forEach(controller => {
      if(controller.userData.selected && controller.userData.vectorName) {
        const origin = new THREE.Vector3();
        origin.setFromMatrixPosition(controller.matrixWorld);
        
        const name = controller.userData.vectorName;
        if(name === 'A'){
          vecA.copy(origin);
          updateSliderFromVector('A', vecA);
        } else if(name === 'B'){
          vecB.copy(origin);
          updateSliderFromVector('B', vecB);
        } else if(name === 'C'){
          vecC.copy(origin);
          updateSliderFromVector('C', vecC);
        }
        updateAllVectors();
      }
    });
  }

  function createGrid() {
    grid = new THREE.Group();
    
    const gridXY = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
    gridXY.rotation.x = Math.PI / 2;
    grid.add(gridXY);

    const gridXZ = new THREE.GridHelper(20, 20, 0x334444, 0x112222);
    grid.add(gridXZ);

    const gridYZ = new THREE.GridHelper(20, 20, 0x443344, 0x221122);
    gridYZ.rotation.z = Math.PI / 2;
    grid.add(gridYZ);

    const axesHelper = new THREE.AxesHelper(12);
    grid.add(axesHelper);

    const origin = new THREE.Mesh(
      new THREE.SphereGeometry(0.15, 16, 16),
      new THREE.MeshBasicMaterial({color: 0xffff00})
    );
    grid.add(origin);

    scene.add(grid);
  }

  function createArrow(color) {
    const group = new THREE.Group();
    group.userData.isArrow = true;

    const shaftGeom = new THREE.CylinderGeometry(0.06, 0.06, 1, 16);
    const shaftMat = new THREE.MeshStandardMaterial({
      color: color,
      metalness: 0.3,
      roughness: 0.6
    });
    const shaft = new THREE.Mesh(shaftGeom, shaftMat);
    shaft.position.y = 0.5;
    group.add(shaft);

    const headGeom = new THREE.ConeGeometry(0.18, 0.4, 16);
    const headMat = new THREE.MeshStandardMaterial({
      color: color,
      metalness: 0.3,
      roughness: 0.6
    });
    const head = new THREE.Mesh(headGeom, headMat);
    head.position.y = 1.2;
    group.add(head);

    return group;
  }

  function createVectorArrows() {
    vectorAArrow = createArrow(0x3366ff);
    vectorAArrow.userData.vectorName = 'A';
    scene.add(vectorAArrow);

    vectorBArrow = createArrow(0xff3366);
    vectorBArrow.userData.vectorName = 'B';
    scene.add(vectorBArrow);

    vectorCArrow = createArrow(0x33ff66);
    vectorCArrow.userData.vectorName = 'C';
    scene.add(vectorCArrow);

    vectorALabel = createLabelSprite('A', '#5588ff');
    vectorBLabel = createLabelSprite('B', '#ff5588');
    vectorCLabel = createLabelSprite('C', '#55ff88');

    scene.add(vectorALabel);
    scene.add(vectorBLabel);
    scene.add(vectorCLabel);

    const helperGeom = new THREE.SphereGeometry(0.3, 16, 16);
    
    const helperA = new THREE.Mesh(helperGeom, new THREE.MeshBasicMaterial({
      color: 0x3366ff,
      transparent: true,
      opacity: 0.5
    }));
    helperA.userData.vectorName = 'A';
    helperA.userData.isHelper = true;
    scene.add(helperA);
    vectorAArrow.userData.helper = helperA;

    const helperB = new THREE.Mesh(helperGeom, new THREE.MeshBasicMaterial({
      color: 0xff3366,
      transparent: true,
      opacity: 0.5
    }));
    helperB.userData.vectorName = 'B';
    helperB.userData.isHelper = true;
    scene.add(helperB);
    vectorBArrow.userData.helper = helperB;

    const helperC = new THREE.Mesh(helperGeom, new THREE.MeshBasicMaterial({
      color: 0x33ff66,
      transparent: true,
      opacity: 0.5
    }));
    helperC.userData.vectorName = 'C';
    helperC.userData.isHelper = true;
    scene.add(helperC);
    vectorCArrow.userData.helper = helperC;
  }

  function createCrossProductArrows() {
    crossProductABArrow = createArrow(0xffff00);
    crossProductABArrow.userData.vectorName = 'AÃ—B';
    crossProductABArrow.visible = false;
    scene.add(crossProductABArrow);

    crossProductACArrow = createArrow(0x00ffff);
    crossProductACArrow.userData.vectorName = 'AÃ—C';
    crossProductACArrow.visible = false;
    scene.add(crossProductACArrow);

    crossProductBCArrow = createArrow(0xff00ff);
    crossProductBCArrow.userData.vectorName = 'BÃ—C';
    crossProductBCArrow.visible = false;
    scene.add(crossProductBCArrow);

    crossProductABLabel = createLabelSprite('AÃ—B', '#ffff88');
    scene.add(crossProductABLabel);
    crossProductABLabel.visible = false;

    crossProductACLabel = createLabelSprite('AÃ—C', '#88ffff');
    scene.add(crossProductACLabel);
    crossProductACLabel.visible = false;

    crossProductBCLabel = createLabelSprite('BÃ—C', '#ff88ff');
    scene.add(crossProductBCLabel);
    crossProductBCLabel.visible = false;
  }

  function createLabelSprite(text, color) {
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');
    ctx.font = 'bold 60px Arial';
    ctx.fillStyle = color;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, 64, 64);
    const texture = new THREE.CanvasTexture(canvas);
    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map: texture, transparent:true}));
    sprite.scale.set(0.8, 0.8, 1);
    return sprite;
  }

  function createAngleSprite(text, color) {
    const canvas = document.createElement('canvas');
    canvas.width = 200;
    canvas.height = 80;
    const ctx = canvas.getContext('2d');
    
    ctx.font = 'bold 36px Arial';
    const textWidth = ctx.measureText(text).width;
    const padding = 8;
    
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(100 - textWidth/2 - padding, 40 - 20, textWidth + padding * 2, 40);
    
    ctx.fillStyle = color;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, 100, 40);
    
    const texture = new THREE.CanvasTexture(canvas);
    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({
      map: texture, 
      transparent: true,
      depthTest: false,
      depthWrite: false
    }));
    sprite.scale.set(1.5, 0.6, 1);
    sprite.renderOrder = 999;
    return sprite;
  }

  function updateAngleSprite(sprite, text, color) {
    const canvas = document.createElement('canvas');
    canvas.width = 200;
    canvas.height = 80;
    const ctx = canvas.getContext('2d');
    
    ctx.font = 'bold 36px Arial';
    const textWidth = ctx.measureText(text).width;
    const padding = 8;
    
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(100 - textWidth/2 - padding, 40 - 20, textWidth + padding * 2, 40);
    
    ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, 100, 40);
    
    sprite.material.map.dispose();
    sprite.material.map = new THREE.CanvasTexture(canvas);
    sprite.material.needsUpdate = true;
  }
//å°„å½±ç·š
  function createProjectionLines() {
    const lineAB = new THREE.Line(
      new THREE.BufferGeometry(),
      new THREE.LineBasicMaterial({color: 0x00ff00, transparent:true, opacity:0.6})
    );
    scene.add(lineAB);
    projectionLines.push({line: lineAB, from: vecB, to: vecA});

    const lineAC = new THREE.Line(
      new THREE.BufferGeometry(),
      new THREE.LineBasicMaterial({color: 0x00ffff, transparent:true, opacity:0.6})
    );
    scene.add(lineAC);
    projectionLines.push({line: lineAC, from: vecC, to: vecA});

    const lineBC = new THREE.Line(
      new THREE.BufferGeometry(),
      new THREE.LineBasicMaterial({color: 0xff00ff, transparent:true, opacity:0.6})
    );
    scene.add(lineBC);
    projectionLines.push({line: lineBC, from: vecC, to: vecB});
  }

  function createAngleArcs() {
    for(let i = 0; i < 3; i++){
      const arcGeometry = new THREE.BufferGeometry();
      const arcMaterial = new THREE.LineBasicMaterial({
        color: 0xffff00,
        transparent: true,
        opacity: 0.9,
        depthTest: false,
        depthWrite: false
      });
      const arc = new THREE.Line(arcGeometry, arcMaterial);
      arc.renderOrder = 999;
      scene.add(arc);
      angleArcs.push(arc);
      
      const angleLabel = createAngleSprite('0Â°', '#ffff00');
      scene.add(angleLabel);
      angleLabels.push(angleLabel);
    }
  }
//å††å¼§
  function createAngleArc(v1, v2, radius, segments = 32) {
    const angle = Math.acos(Math.max(-1, Math.min(1, v1.dot(v2) / (v1.length() * v2.length()))));
    
    if(angle < 0.01) return [];
    
    const points = [];
    const v1Norm = v1.clone().normalize();
    const v2Norm = v2.clone().normalize();
    const axis = new THREE.Vector3().crossVectors(v1Norm, v2Norm).normalize();
    
    for(let i = 0; i <= segments; i++){
      const t = i / segments;
      const currentAngle = angle * t;
      const rotatedVec = v1Norm.clone().applyAxisAngle(axis, currentAngle);
      points.push(rotatedVec.multiplyScalar(radius));
    }
    
    return points;
  }

  function createParallelogram() {
    parallelogram = new THREE.Group();
    parallelogram.visible = false;
    scene.add(parallelogram);
  }

  function updateParallelogram() {
    parallelogram.children.forEach(child => {
      child.geometry.dispose();
      child.material.dispose();
    });
    parallelogram.clear();

    const origin = new THREE.Vector3(0, 0, 0);
    const pA = vecA.clone();
    const pB = vecB.clone();
    const pC = vecC.clone();
    const pAB = vecA.clone().add(vecB);
    const pAC = vecA.clone().add(vecC);
    const pBC = vecB.clone().add(vecC);
    const pABC = vecA.clone().add(vecB).add(vecC);

    parallelogram.add(createFace(origin, pA, pAB, pB, 0x6633cc));
    parallelogram.add(createFace(origin, pA, pAC, pC, 0x33cc66));
    parallelogram.add(createFace(origin, pB, pBC, pC, 0xcc6633));
    parallelogram.add(createFace(pA, pAB, pABC, pAC, 0x9966cc));
    parallelogram.add(createFace(pB, pAB, pABC, pBC, 0xcc9966));
    parallelogram.add(createFace(pC, pAC, pABC, pBC, 0x66cc99));
  }

  function createFace(v1, v2, v3, v4, color) {
    const geometry = new THREE.BufferGeometry();
    const vertices = new Float32Array([
      ...v1.toArray(), ...v2.toArray(), ...v3.toArray(),
      ...v1.toArray(), ...v3.toArray(), ...v4.toArray()
    ]);
    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
    const material = new THREE.MeshBasicMaterial({
      color: color,
      transparent: true,
      opacity: 0.25,
      side: THREE.DoubleSide
    });
    return new THREE.Mesh(geometry, material);
  }

  function updateArrow(arrow, vec) {
    const len = vec.length();
    if(len < 0.01){
      arrow.visible = false;
      return;
    }
    arrow.visible = true;
    arrow.position.set(0, 0, 0);

    const dir = vec.clone().normalize();
    const axis = new THREE.Vector3(0, 1, 0);
    const quat = new THREE.Quaternion();
    quat.setFromUnitVectors(axis, dir);
    arrow.quaternion.copy(quat);

    const shaft = arrow.children[0];
    const head = arrow.children[1];

    shaft.scale.set(1, len, 1);
    shaft.position.set(0, len / 2, 0);
    head.position.set(0, len + 0.2, 0);
    
    arrow.userData.tipPosition = vec.clone();
  }

  function updateProjectionLine(projData) {
    const {line, from, to} = projData;
    
    if(to.length() < 0.01 || from.length() < 0.01){
      line.visible = false;
      return;
    }
    line.visible = true;

    const toNorm = to.clone().normalize();
    const projLength = from.dot(toNorm);
    const projVec = toNorm.clone().multiplyScalar(projLength);

    const points = [from.clone(), projVec.clone()];
    line.geometry.setFromPoints(points);

    const dotProd = from.dot(to);
    line.material.color.set(dotProd >= 0 ? 0x00ff00 : 0xff0000);
  }
//çŸ¢å°ã®å¯è¦–åŒ–ã€è¨ˆç®—
  function updateAllVectors() {
    updateArrow(vectorAArrow, vecA);
    updateArrow(vectorBArrow, vecB);
    updateArrow(vectorCArrow, vecC);

    const isAVisible = document.getElementById('toggleVectorA').checked;
    const isBVisible = document.getElementById('toggleVectorB').checked;
    const isCVisible = document.getElementById('toggleVectorC').checked;
    
    const crossAB = new THREE.Vector3().crossVectors(vecA, vecB);
    const crossBC = new THREE.Vector3().crossVectors(vecB, vecC);
    const crossAC = new THREE.Vector3().crossVectors(vecA, vecC);

    vectorAArrow.visible = isAVisible && vecA.length() >= 0.01;
    vectorBArrow.visible = isBVisible && vecB.length() >= 0.01;
    vectorCArrow.visible = isCVisible && vecC.length() >= 0.01;

    if(vectorAArrow.userData.helper) {
      vectorAArrow.userData.helper.position.copy(vecA);
      vectorAArrow.userData.helper.visible = isAVisible && vecA.length() >= 0.01;
    }
    if(vectorBArrow.userData.helper) {
      vectorBArrow.userData.helper.position.copy(vecB);
      vectorBArrow.userData.helper.visible = isBVisible && vecB.length() >= 0.01;
    }
    if(vectorCArrow.userData.helper) {
      vectorCArrow.userData.helper.position.copy(vecC);
      vectorCArrow.userData.helper.visible = isCVisible && vecC.length() >= 0.01;
    }

    vectorALabel.position.copy(vecA).add(new THREE.Vector3(0.4, 0.4, 0.4));
    vectorBLabel.position.copy(vecB).add(new THREE.Vector3(0.4, 0.4, 0.4));
    vectorCLabel.position.copy(vecC).add(new THREE.Vector3(0.4, 0.4, 0.4));

    vectorALabel.visible = isAVisible;
    vectorBLabel.visible = isBVisible;
    vectorCLabel.visible = isCVisible;
    
    const prevVisibleAB = crossProductABArrow.visible;
    const prevVisibleAC = crossProductACArrow.visible;
    const prevVisibleBC = crossProductBCArrow.visible;
    
    updateArrow(crossProductABArrow, crossAB);
    updateArrow(crossProductACArrow, crossAC);
    updateArrow(crossProductBCArrow, crossBC);
    
    crossProductABArrow.visible = prevVisibleAB && crossAB.length() >= 0.01;
    crossProductACArrow.visible = prevVisibleAC && crossAC.length() >= 0.01;
    crossProductBCArrow.visible = prevVisibleBC && crossBC.length() >= 0.01;

    crossProductABLabel.position.copy(crossAB).add(new THREE.Vector3(0.4, 0.4, 0.4));
    crossProductABLabel.visible = crossProductABArrow.visible;

    crossProductACLabel.position.copy(crossAC).add(new THREE.Vector3(0.4, 0.4, 0.4));
    crossProductACLabel.visible = crossProductACArrow.visible;

    crossProductBCLabel.position.copy(crossBC).add(new THREE.Vector3(0.4, 0.4, 0.4));
    crossProductBCLabel.visible = crossProductBCArrow.visible;

    projectionLines[0].from = vecB;
    projectionLines[0].to = vecA;
    projectionLines[1].from = vecC;
    projectionLines[1].to = vecA;
    projectionLines[2].from = vecC;
    projectionLines[2].to = vecB;
    
    if(isAVisible && isBVisible) {
      updateProjectionLine(projectionLines[0]);
    } else {
      projectionLines[0].line.visible = false;
    }
    
    if(isAVisible && isCVisible) {
      updateProjectionLine(projectionLines[1]);
    } else {
      projectionLines[1].line.visible = false;
    }
    
    if(isBVisible && isCVisible) {
      updateProjectionLine(projectionLines[2]);
    } else {
      projectionLines[2].line.visible = false;
    }
    
    updateParallelogram();
    updateAngleDisplays();
    updateCalculations();
    updateDotProductGraph();
    updateUnitCircleGraph();

     // VRãƒ¢ãƒ¼ãƒ‰æ™‚ã¯è¨ˆç®—ãƒ‘ãƒãƒ«ã‚’æ›´æ–°
 if(isVRMode && vrCalcPanel) {
   updateVRCalcPanel(vrCalcPanel);
 }
}

//è§’åº¦
  function updateAngleDisplays() {
    const isAVisible = document.getElementById('toggleVectorA').checked;
    const isBVisible = document.getElementById('toggleVectorB').checked;
    const isCVisible = document.getElementById('toggleVectorC').checked;

    const calcAngle = (v1, v2) => {
      const m1 = v1.length();
      const m2 = v2.length();
      if(m1 < 0.001 || m2 < 0.001) return 0;
      const cosAngle = v1.dot(v2) / (m1 * m2);
      let angle = Math.acos(Math.max(-1, Math.min(1, cosAngle))) * 180 / Math.PI;
      const rounded = Math.round(angle);
      if(Math.abs(angle - rounded) < 0.1) angle = rounded;
      return angle;
    };

    const radius = 0.7;
    const pairs = [
      {v1: vecA, v2: vecB, arc: angleArcs[0], label: angleLabels[0], radius: radius, color: 0xffff00, name: 'âˆ  AB', visible: isAVisible && isBVisible},
      {v1: vecA, v2: vecC, arc: angleArcs[1], label: angleLabels[1], radius: radius * 0.85, color: 0x00ffff, name: 'âˆ  AC', visible: isAVisible && isCVisible},
      {v1: vecB, v2: vecC, arc: angleArcs[2], label: angleLabels[2], radius: radius * 0.7, color: 0xff00ff, name: 'âˆ  BC', visible: isBVisible && isCVisible}
    ];

    pairs.forEach(({v1, v2, arc, label, radius, color, name, visible}) => {
      const angle = calcAngle(v1, v2);
      if(visible && v1.length() > 0.1 && v2.length() > 0.1 && angle > 1){
        const arcPoints = createAngleArc(v1, v2, radius);
        arc.geometry.setFromPoints(arcPoints);
        arc.material.color.set(color);
        arc.visible = true;
        
        const midAngle = Math.acos(Math.max(-1, Math.min(1, v1.dot(v2) / (v1.length() * v2.length())))) / 2;
        const axis = new THREE.Vector3().crossVectors(v1.clone().normalize(), v2.clone().normalize()).normalize();
        const labelPos = v1.clone().normalize().applyAxisAngle(axis, midAngle).multiplyScalar(radius * 1.8);
        
        label.position.copy(labelPos);
        updateAngleSprite(label, `${name}: ${angle.toFixed(1)}Â°`, color);
        label.visible = true;
      } else {
        arc.visible = false;
        label.visible = false;
      }
    });
  }

  function updateCalculations() {
    const dotAB = vecA.dot(vecB);
    const dotAC = vecA.dot(vecC);
    const dotBC = vecB.dot(vecC);
    const magA = vecA.length();
    const magB = vecB.length();
    const magC = vecC.length();

    const crossAB = new THREE.Vector3().crossVectors(vecA, vecB);
    const crossAC = new THREE.Vector3().crossVectors(vecA, vecC);
    const crossBC = new THREE.Vector3().crossVectors(vecB, vecC);
    const magCrossAB = crossAB.length();
    const magCrossAC = crossAC.length();
    const magCrossBC = crossBC.length();

    const calcAngle = (v1, v2) => {
      const m1 = v1.length();
      const m2 = v2.length();
      if(m1 < 0.001 || m2 < 0.001) return 0;
      const cosAngle = v1.dot(v2) / (m1 * m2);
      let angle = Math.acos(Math.max(-1, Math.min(1, cosAngle))) * 180 / Math.PI;
      const rounded = Math.round(angle);
      if(Math.abs(angle - rounded) < 0.1) angle = rounded;
      return angle.toFixed(1);
    };

   document.getElementById('dotProductAB').textContent = dotAB.toFixed(2);
document.getElementById('dotProductAC').textContent = dotAC.toFixed(2);
document.getElementById('dotProductBC').textContent = dotBC.toFixed(2);
document.getElementById('dotMagnitudeAB').textContent = Math.abs(dotAB).toFixed(2);
document.getElementById('dotMagnitudeAC').textContent = Math.abs(dotAC).toFixed(2);
document.getElementById('dotMagnitudeBC').textContent = Math.abs(dotBC).toFixed(2);

// å¤–ç©ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆx, y, zæˆåˆ†ï¼‰ã®è¡¨ç¤ºã‚’è¿½åŠ 
document.getElementById('crossVectorAB').textContent = `(${crossAB.x.toFixed(2)}, ${crossAB.y.toFixed(2)}, ${crossAB.z.toFixed(2)})`;
document.getElementById('crossVectorAC').textContent = `(${crossAC.x.toFixed(2)}, ${crossAC.y.toFixed(2)}, ${crossAC.z.toFixed(2)})`;
document.getElementById('crossVectorBC').textContent = `(${crossBC.x.toFixed(2)}, ${crossBC.y.toFixed(2)}, ${crossBC.z.toFixed(2)})`;

document.getElementById('crossProductAB').textContent = magCrossAB.toFixed(2);
document.getElementById('crossProductAC').textContent = magCrossAC.toFixed(2);
document.getElementById('crossProductBC').textContent = magCrossBC.toFixed(2);
    document.getElementById('magnitudeA').textContent = magA.toFixed(2);
    document.getElementById('magnitudeB').textContent = magB.toFixed(2);
    document.getElementById('magnitudeC').textContent = magC.toFixed(2);
    document.getElementById('angleAB').textContent = calcAngle(vecA, vecB) + 'Â°';
    document.getElementById('angleAC').textContent = calcAngle(vecA, vecC) + 'Â°';
    document.getElementById('angleBC').textContent = calcAngle(vecB, vecC) + 'Â°';
  }

function updateDotProductGraph() {
    const canvas = document.getElementById('graphCanvas');
    const container = document.getElementById('dotProductGraph');
    canvas.width = container.clientWidth - 20;
    canvas.height = container.clientHeight - 20;
    const ctx = canvas.getContext('2d');
    const w = canvas.width;
    const h = canvas.height;
    
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
    ctx.fillRect(0, 0, w, h);
    
    const centerX = w / 2 + dotOffsetX;
    const centerY = h / 2 + dotOffsetY;
    const scale = dotGraphScale;
    const scaleRatio = scale / 15;
    const textScaleRatio = Math.sqrt(scaleRatio);
    
    ctx.strokeStyle = '#444';
    ctx.lineWidth = Math.max(0.8, 0.8 * textScaleRatio);
    ctx.beginPath();
    ctx.moveTo(0, centerY);
    ctx.lineTo(w, centerY);
    ctx.moveTo(centerX, 0);
    ctx.lineTo(centerX, h);
    ctx.stroke();
    
    ctx.fillStyle = '#888';
    ctx.font = Math.round(9 * textScaleRatio) + 'px Arial';
    ctx.fillText('X', w - 15, centerY - 5);
    ctx.fillText('Y', centerX + 5, 12);
    
    function drawVector(x, y, color, label) {
      const screenX = centerX + x * scale;
      const screenY = centerY - y * scale;
      
      ctx.strokeStyle = color;
      ctx.lineWidth = Math.max(1.5, 1.5 * textScaleRatio);
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(screenX, screenY);
      ctx.stroke();
      
      const angle = Math.atan2(screenY - centerY, screenX - centerX);
      const headLen = Math.max(6, 6 * textScaleRatio);
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(screenX, screenY);
      ctx.lineTo(
        screenX - headLen * Math.cos(angle - Math.PI / 6),
        screenY - headLen * Math.sin(angle - Math.PI / 6)
      );
      ctx.lineTo(
        screenX - headLen * Math.cos(angle + Math.PI / 6),
        screenY - headLen * Math.sin(angle + Math.PI / 6)
      );
      ctx.closePath();
      ctx.fill();
      
      ctx.fillStyle = color;
      const labelFontSize = Math.max(10, Math.round(10 * textScaleRatio));
      const coordFontSize = Math.max(8, Math.round(8 * textScaleRatio));
      ctx.font = 'bold ' + labelFontSize + 'px Arial';
      
      const labelWidth = ctx.measureText(label).width;
      const coordText = `(${x.toFixed(1)}, ${y.toFixed(1)})`;
      ctx.font = coordFontSize + 'px Arial';
      const coordWidth = ctx.measureText(coordText).width;
      const maxWidth = Math.max(labelWidth, coordWidth);
      
      let offsetX = (x > 0 ? 10 : -10 - maxWidth) * textScaleRatio;
      let offsetY = (y > 0 ? -5 : 15) * textScaleRatio;
      
      if (screenX + offsetX + maxWidth > w - 5) {
        offsetX = -maxWidth - 5;
      }
      if (screenX + offsetX < 5) {
        offsetX = 5;
      }
      if (screenY + offsetY + coordFontSize + 5 > h) {
        offsetY = -coordFontSize - 10;
      }
      if (screenY + offsetY - labelFontSize < 5) {
        offsetY = labelFontSize + 5;
      }
      
      ctx.fillStyle = color;
      ctx.font = 'bold ' + labelFontSize + 'px Arial';
      ctx.fillText(label, screenX + offsetX, screenY + offsetY);
      ctx.font = coordFontSize + 'px Arial';
      ctx.fillText(coordText, screenX + offsetX, screenY + offsetY + labelFontSize + 2);
    }
    
    drawVector(vecA.x, vecA.y, '#3366ff', 'A');
    drawVector(vecB.x, vecB.y, '#ff3366', 'B');
    drawVector(vecC.x, vecC.y, '#33ff66', 'C');
  }

  function updateUnitCircleGraph() {
    const canvas = document.getElementById('unitCircleCanvas');
    const container = document.getElementById('unitCircleGraph');
    canvas.width = container.clientWidth - 20;
    canvas.height = container.clientHeight - 20;
    const ctx = canvas.getContext('2d');
    const w = canvas.width;
    const h = canvas.height;
    
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
    ctx.fillRect(0, 0, w, h);
    
    const centerX = w / 2 + unitOffsetX;
    const centerY = h / 2 + unitOffsetY;
    const radius = unitGraphScale;
    const scaleRatio = radius / 70;
    const textScaleRatio = Math.sqrt(scaleRatio);
    
    const angle = Math.atan2(vecA.y, vecA.x);
    const cosTheta = Math.cos(angle);
    const sinTheta = Math.sin(angle);
    
    ctx.strokeStyle = '#666';
    ctx.lineWidth = Math.max(1.5, 1.5 * textScaleRatio);
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    ctx.stroke();
    
    ctx.strokeStyle = '#444';
    ctx.lineWidth = Math.max(1, 1 * textScaleRatio);
    ctx.beginPath();
    ctx.moveTo(centerX - radius - 10 * scaleRatio, centerY);
    ctx.lineTo(centerX + radius + 10 * scaleRatio, centerY);
    ctx.moveTo(centerX, centerY - radius - 10 * scaleRatio);
    ctx.lineTo(centerX, centerY + radius + 10 * scaleRatio);
    ctx.stroke();
    
    const pointX = centerX + cosTheta * radius;
    const pointY = centerY - sinTheta * radius;
    
    ctx.strokeStyle = '#3366ff';
    ctx.lineWidth = Math.max(1.5, 1.5 * textScaleRatio);
    ctx.beginPath();
    ctx.moveTo(centerX, centerY);
    ctx.lineTo(pointX, pointY);
    ctx.stroke();
    
    ctx.strokeStyle = '#ff6600';
    ctx.lineWidth = Math.max(1.5, 1.5 * textScaleRatio);
    ctx.beginPath();
    ctx.moveTo(centerX, centerY);
    ctx.lineTo(pointX, centerY);
    ctx.stroke();
    
    ctx.strokeStyle = '#00ff88';
    ctx.lineWidth = Math.max(1.5, 1.5 * textScaleRatio);
    ctx.beginPath();
    ctx.moveTo(pointX, centerY);
    ctx.lineTo(pointX, pointY);
    ctx.stroke();
    
    const markSize = Math.max(6, 6 * textScaleRatio);
    ctx.strokeStyle = '#888';
    ctx.lineWidth = Math.max(1, 1 * textScaleRatio);
    ctx.beginPath();
    ctx.moveTo(pointX - markSize, centerY);
    ctx.lineTo(pointX - markSize, centerY - markSize);
    ctx.lineTo(pointX, centerY - markSize);
    ctx.stroke();
    
    ctx.fillStyle = '#3366ff';
    ctx.beginPath();
    ctx.arc(pointX, pointY, Math.max(3, 3 * textScaleRatio), 0, Math.PI * 2);
    ctx.fill();
    
    const baseFontSize = Math.max(9, Math.round(9 * textScaleRatio));
    const smallFontSize = Math.max(8, Math.round(8 * textScaleRatio));
    
    ctx.fillStyle = '#fff';
    ctx.font = 'bold ' + baseFontSize + 'px Arial';
    let r1X = centerX + (pointX - centerX) / 2 - 10 * textScaleRatio;
    let r1Y = centerY + (pointY - centerY) / 2 - 5 * textScaleRatio;
    const r1Text = 'r=1';
    const r1Width = ctx.measureText(r1Text).width;
    
    if (r1X < 5) r1X = 5;
    if (r1X + r1Width > w - 5) r1X = w - r1Width - 5;
    if (r1Y < baseFontSize + 5) r1Y = baseFontSize + 5;
    if (r1Y > h - 5) r1Y = h - 5;
    
    ctx.fillText(r1Text, r1X, r1Y);
    
    ctx.fillStyle = '#ff6600';
    ctx.font = baseFontSize + 'px Arial';
    const cosText = `cosÎ¸=${cosTheta.toFixed(2)}`;
    const cosWidth = ctx.measureText(cosText).width;
    let cosX = centerX + 5 * textScaleRatio;
    let cosY = centerY + 15 * textScaleRatio;
    
    if (cosX + cosWidth > w - 5) cosX = w - cosWidth - 5;
    if (cosY > h - 5) cosY = h - 5;
    if (cosY < baseFontSize + 5) cosY = baseFontSize + 5;
    
    ctx.fillText(cosText, cosX, cosY);
    
    ctx.fillStyle = '#00ff88';
    const sinText = `sinÎ¸=${sinTheta.toFixed(2)}`;
    const sinWidth = ctx.measureText(sinText).width;
    let sinX = pointX + 8 * textScaleRatio;
    let sinY = centerY + (pointY - centerY) / 2;
    
    if (sinX + sinWidth > w - 5) sinX = pointX - sinWidth - 8 * textScaleRatio;
    if (sinX < 5) sinX = 5;
    if (sinY < baseFontSize + 5) sinY = baseFontSize + 5;
    if (sinY > h - 5) sinY = h - 5;
    
    ctx.fillText(sinText, sinX, sinY);
    
    ctx.fillStyle = '#aaa';
    ctx.font = smallFontSize + 'px Arial';
    const thetaText = `Î¸=${(angle * 180 / Math.PI).toFixed(1)}Â°`;
    const thetaWidth = ctx.measureText(thetaText).width;
    let thetaX = centerX + 15 * textScaleRatio;
    let thetaY = centerY - 10 * textScaleRatio;
    
    if (thetaX + thetaWidth > w - 5) thetaX = w - thetaWidth - 5;
    if (thetaY < smallFontSize + 5) thetaY = centerY + 25 * textScaleRatio;
    if (thetaY > h - 5) thetaY = h - 5;
    
    ctx.fillText(thetaText, thetaX, thetaY);
  }

  function createTransformControls() {
    transformControl = new THREE.TransformControls(camera, renderer.domElement);
    transformControl.setMode('translate');
    transformControl.setSpace('world');
    transformControl.setSize(0.8);
    
    let savedCameraTarget = new THREE.Vector3();
    let savedCameraPosition = new THREE.Vector3();
    
    transformControl.addEventListener('dragging-changed', (event) => {
      if(event.value) {
        controls.enabled = false;
        savedCameraTarget.copy(controls.target);
        savedCameraPosition.copy(camera.position);
      } else {
        controls.enabled = true;
        controls.target.set(0, 0, 0);
        controls.update();
      }
    });
    
    transformControl.addEventListener('change', () => {
      if(transformControl.object){
        const helperPos = transformControl.object.position.clone();
        const name = transformControl.object.userData.vectorName;
        
        if(name === 'A'){
          vecA.copy(helperPos);
          updateSliderFromVector('A', vecA);
        } else if(name === 'B'){
          vecB.copy(helperPos);
          updateSliderFromVector('B', vecB);
        } else if(name === 'C'){
          vecC.copy(helperPos);
          updateSliderFromVector('C', vecC);
        }
        updateAllVectors();
        
        controls.target.set(0, 0, 0);
      }
    });
    
    scene.add(transformControl);
    transformControl.visible = false;
  }

  function updateSliderFromVector(name, vec) {
    document.getElementById(`vector${name}X`).value = vec.x.toFixed(1);
    document.getElementById(`vector${name}Y`).value = vec.y.toFixed(1);
    document.getElementById(`vector${name}Z`).value = vec.z.toFixed(1);
    document.getElementById(`vector${name}X-value`).value = vec.x.toFixed(1);
    document.getElementById(`vector${name}Y-value`).value = vec.y.toFixed(1);
    document.getElementById(`vector${name}Z-value`).value = vec.z.toFixed(1);
  }

  function setupSliderControls() {
    const sliders = [
      {id: 'vectorAX', vec: vecA, key:'x', labelId:'vectorAX-value'},
      {id: 'vectorAY', vec: vecA, key:'y', labelId:'vectorAY-value'},
      {id: 'vectorAZ', vec: vecA, key:'z', labelId:'vectorAZ-value'},
      {id: 'vectorBX', vec: vecB, key:'x', labelId:'vectorBX-value'},
      {id: 'vectorBY', vec: vecB, key:'y', labelId:'vectorBY-value'},
      {id: 'vectorBZ', vec: vecB, key:'z', labelId:'vectorBZ-value'},
      {id: 'vectorCX', vec: vecC, key:'x', labelId:'vectorCX-value'},
      {id: 'vectorCY', vec: vecC, key:'y', labelId:'vectorCY-value'},
      {id: 'vectorCZ', vec: vecC, key:'z', labelId:'vectorCZ-value'},
    ];

    sliders.forEach(({id, vec, key, labelId}) => {
      const slider = document.getElementById(id);
      const input = document.getElementById(labelId);
      
      slider.addEventListener('input', () => {
        const value = parseFloat(slider.value);
        vec[key] = value;
        input.value = value.toFixed(1);
        updateAllVectors();
      });

      input.addEventListener('input', () => {
        let value = parseFloat(input.value);
        if(!isNaN(value)) {
          value = Math.max(-10, Math.min(10, value));
          vec[key] = value;
          slider.value = value;
          updateAllVectors();
        }
      });

      input.addEventListener('keydown', (e) => {
        if(e.key === 'Enter') {
          input.blur();
        }
      });
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      vecA.set(3, 2, 1);
      vecB.set(2, 3, 0.5);
      vecC.set(1, 1, 3);
      sliders.forEach(({id, vec, key, labelId}) => {
        document.getElementById(id).value = vec[key];
        document.getElementById(labelId).value = vec[key].toFixed(1);
      });
      updateAllVectors();
    });

    document.getElementById('toggleGridBtn').addEventListener('click', () => {
      grid.visible = !grid.visible;
    });

    document.getElementById('togglePlaneBtn').addEventListener('click', () => {
      parallelogram.visible = !parallelogram.visible;
    });

    document.getElementById('toggleGraphBtn').addEventListener('click', () => {
      const dotGraph = document.getElementById('dotProductGraph');
      const unitGraph = document.getElementById('unitCircleGraph');
      const isVisible = dotGraph.style.display !== 'none';
      dotGraph.style.display = isVisible ? 'none' : 'block';
      unitGraph.style.display = isVisible ? 'none' : 'block';
    });

    document.getElementById('toggleCrossBtn').addEventListener('click', () => {
      const newVisibility = !crossProductABArrow.visible;
      crossProductABArrow.visible = newVisibility;
      crossProductACArrow.visible = newVisibility;
      crossProductBCArrow.visible = newVisibility;
      crossProductABLabel.visible = newVisibility;
      crossProductACLabel.visible = newVisibility;
      crossProductBCLabel.visible = newVisibility;
    });

    document.getElementById('toggleVectorA').addEventListener('change', (e) => {
      updateAllVectors();
    });

    document.getElementById('toggleVectorB').addEventListener('change', (e) => {
      updateAllVectors();
    });

    document.getElementById('toggleVectorC').addEventListener('change', (e) => {
      updateAllVectors();
    });
//VR
    document.getElementById('module').addEventListener('click', async () => {
 try {
   if (!navigator.xr) {
     alert('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯WebXRã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“');
     return;
   }
   const session = await navigator.xr.requestSession('immersive-vr', {
     optionalFeatures: ['local-floor', 'bounded-floor']
   });
   await renderer.xr.setSession(session);
   isVRMode = true;
   document.getElementById('vrInfo').style.display = 'block';
   session.addEventListener('end', () => {
     isVRMode = false;
     document.getElementById('vrInfo').style.display = 'none';
   });
 } catch(err) {
   console.error('VRé–‹å§‹å¤±æ•—:', err);
   alert('VRã‚»ãƒƒã‚·ãƒ§ãƒ³ã®é–‹å§‹ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + err.message);
 }
});
  }

  function animate() {
    if(!isVRMode) {
      if(!transformControl.dragging) {
        controls.target.set(0, 0, 0);
      }
      controls.update();
    } else {
      updateVRControllers();
    }
    renderer.render(scene, camera);
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    adjustPanelPositions();
  }

  function adjustPanelPositions() {
    const infoBox = document.getElementById('info');
    const learningBox = document.getElementById('learningBox');
    const dotGraph = document.getElementById('dotProductGraph');
    const unitGraph = document.getElementById('unitCircleGraph');
    
    if (infoBox.offsetLeft + infoBox.offsetWidth > window.innerWidth) {
      infoBox.style.left = Math.max(10, window.innerWidth - infoBox.offsetWidth - 10) + 'px';
    }
    if (infoBox.offsetTop + infoBox.offsetHeight > window.innerHeight) {
      infoBox.style.top = Math.max(10, window.innerHeight - infoBox.offsetHeight - 10) + 'px';
    }
    
    if (learningBox.offsetLeft + learningBox.offsetWidth > window.innerWidth) {
      learningBox.style.left = Math.max(230, window.innerWidth - learningBox.offsetWidth - 10) + 'px';
    }
    if (learningBox.offsetTop + learningBox.offsetHeight > window.innerHeight) {
      learningBox.style.top = Math.max(10, window.innerHeight - learningBox.offsetHeight - 10) + 'px';
    }
    
    if (dotGraph.offsetLeft + dotGraph.offsetWidth > window.innerWidth) {
      dotGraph.style.left = Math.max(10, window.innerWidth - dotGraph.offsetWidth - 10) + 'px';
    }
    if (dotGraph.offsetTop + dotGraph.offsetHeight > window.innerHeight) {
      dotGraph.style.bottom = '10px';
    }
    
    if (unitGraph.offsetLeft + unitGraph.offsetWidth > window.innerWidth) {
      unitGraph.style.left = Math.max(220, window.innerWidth - unitGraph.offsetWidth - 10) + 'px';
    }
    if (unitGraph.offsetTop + unitGraph.offsetHeight > window.innerHeight) {
      unitGraph.style.bottom = '10px';
    }
  }

  let dotOffsetX = 0;
  let dotOffsetY = 0;
  let unitOffsetX = 0;
  let unitOffsetY = 0;
  let dotGraphScale = 15;
  let unitGraphScale = 70;

  init();
  
  document.querySelectorAll('.toggle-box').forEach(btn => {
    btn.addEventListener('mousedown', (e) => {
      e.stopPropagation();
      e.stopImmediatePropagation();
      e.preventDefault();
      return false;
    }, true);
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      e.stopImmediatePropagation();
      e.preventDefault();
      const panelId = btn.closest('#info, #controls').id;
      const panel = document.getElementById(panelId);
      
      if (panelId === 'info') {
        const rect = panel.getBoundingClientRect();
        const savedLeft = rect.left;
        const savedTop = rect.top;
        
        panel.classList.toggle('collapsed');
        
        requestAnimationFrame(() => {
          panel.style.left = savedLeft + 'px';
          panel.style.top = savedTop + 'px';
        });
      } else {
        panel.classList.toggle('collapsed');
      }
      
      return false;
    }, true);
  });
  
  document.querySelector('.toggle-learning').addEventListener('click', (e) => {
    e.stopPropagation();
    e.preventDefault();
    const learningSection = document.querySelector('.learning-section');
    learningSection.classList.toggle('collapsed');
    return false;
  });
  
  document.getElementById('toggleDetailBtn').addEventListener('click', (e) => {
    e.stopPropagation();
    e.preventDefault();
    const detailSection = document.getElementById('detailSection');
    const btn = document.getElementById('toggleDetailBtn');
    
    if (detailSection.classList.contains('expanded')) {
      detailSection.classList.remove('expanded');
      btn.textContent = ' ã‚‚ã£ã¨è©³ã—ã â‰«';
    } else {
      detailSection.classList.add('expanded');
      btn.textContent = ' é–‰ã˜ã‚‹ â‰ª';
    }
    return false;
  });
  
  const infoBox = document.getElementById('info');
  const infoHeader = infoBox.querySelector('.box-header');
  let isDraggingInfo = false;
  let currentXInfo, currentYInfo, initialXInfo, initialYInfo, offsetXInfo, offsetYInfo;

  infoHeader.addEventListener('mousedown', (e) => {
    const target = e.target;
    if (target.classList.contains('toggle-box') || target.tagName === 'BUTTON' || target.closest('.toggle-box')) {
      return false;
    }
    e.stopPropagation();
    e.preventDefault();
    isDraggingInfo = true;
    const rect = infoBox.getBoundingClientRect();
    offsetXInfo = e.clientX - rect.left;
    offsetYInfo = e.clientY - rect.top;
  });

  const learningBox = document.getElementById('learningBox');
  const learningHeader = learningBox.querySelector('.learning-header');
  let isDraggingLearning = false;
  let offsetXLearning, offsetYLearning;

  learningHeader.addEventListener('mousedown', (e) => {
    const target = e.target;
    if (target.classList.contains('toggle-learning') || target.tagName === 'BUTTON' || target.closest('.toggle-learning')) {
      return false;
    }
    e.stopPropagation();
    e.preventDefault();
    isDraggingLearning = true;
    const rect = learningBox.getBoundingClientRect();
    offsetXLearning = e.clientX - rect.left;
    offsetYLearning = e.clientY - rect.top;
  });

  document.addEventListener('mouseup', () => {
    isDraggingInfo = false;
    isDraggingLearning = false;
    isResizingControls = false;
  });
  
  const controlsBox = document.getElementById('controls');
  const resizeHandle = document.querySelector('#controls .resize-handle');
  let isResizingControls = false;
  let startX, startWidth;

  resizeHandle.addEventListener('mousedown', (e) => {
    e.stopPropagation();
    e.preventDefault();
    
    isResizingControls = true;
    startX = e.clientX;
    startWidth = controlsBox.offsetWidth;
  });

  const dotGraph = document.getElementById('dotProductGraph');
  const unitGraph = document.getElementById('unitCircleGraph');
  const dotCanvas = document.getElementById('graphCanvas');
  const unitCanvas = document.getElementById('unitCircleCanvas');
  
  let isDraggingDotGraph = false;
  let isDraggingUnitGraph = false;
  let isPanningDotGraph = false;
  let isPanningUnitGraph = false;
  let isResizingDotGraph = false;
  let isResizingUnitGraph = false;
  let graphOffsetX, graphOffsetY;
  let resizeStartX, resizeStartY, resizeStartWidth, resizeStartHeight;
  let resizeStartDotScale, resizeStartUnitScale;

  const dotResizeHandle = dotGraph.querySelector('.graph-resize-handle');
  const unitResizeHandle = unitGraph.querySelector('.graph-resize-handle');

  if (dotResizeHandle) {
    dotResizeHandle.addEventListener('mousedown', (e) => {
      e.stopPropagation();
      e.preventDefault();
      isResizingDotGraph = true;
      resizeStartX = e.clientX;
      resizeStartY = e.clientY;
      resizeStartWidth = dotGraph.offsetWidth;
      resizeStartHeight = dotGraph.offsetHeight;
    }, true);
  }

  if (unitResizeHandle) {
    unitResizeHandle.addEventListener('mousedown', (e) => {
      e.stopPropagation();
      e.preventDefault();
      isResizingUnitGraph = true;
      resizeStartX = e.clientX;
      resizeStartY = e.clientY;
      resizeStartWidth = unitGraph.offsetWidth;
      resizeStartHeight = unitGraph.offsetHeight;
    }, true);
  }

  dotGraph.addEventListener('mousedown', (e) => {
    if (isResizingDotGraph) return;
    if (e.button === 0 && !e.target.classList.contains('graph-resize-handle')) {
      isDraggingDotGraph = true;
      dotGraph.classList.add('dragging');
      graphOffsetX = e.clientX - dotGraph.offsetLeft;
      graphOffsetY = e.clientY - dotGraph.offsetTop;
      e.preventDefault();
    } else if (e.button === 1) {
      isPanningDotGraph = true;
      graphOffsetX = e.clientX;
      graphOffsetY = e.clientY;
      e.preventDefault();
    }
  });

  unitGraph.addEventListener('mousedown', (e) => {
    if (isResizingUnitGraph) return;
    if (e.button === 0 && !e.target.classList.contains('graph-resize-handle')) {
      isDraggingUnitGraph = true;
      unitGraph.classList.add('dragging');
      graphOffsetX = e.clientX - unitGraph.offsetLeft;
      graphOffsetY = e.clientY - unitGraph.offsetTop;
      e.preventDefault();
    } else if (e.button === 1) {
      isPanningUnitGraph = true;
      graphOffsetX = e.clientX;
      graphOffsetY = e.clientY;
      e.preventDefault();
    }
  });

  document.addEventListener('mouseup', () => {
    isDraggingInfo = false;
    isDraggingLearning = false;
    isResizingControls = false;
    isDraggingDotGraph = false;
    isDraggingUnitGraph = false;
    isPanningDotGraph = false;
    isPanningUnitGraph = false;
    isResizingDotGraph = false;
    isResizingUnitGraph = false;
    dotGraph.classList.remove('dragging');
    unitGraph.classList.remove('dragging');
  });

  document.addEventListener('mousemove', (e) => {
    if (isDraggingInfo) {
      e.preventDefault();
      currentXInfo = e.clientX - offsetXInfo;
      currentYInfo = e.clientY - offsetYInfo;
      infoBox.style.left = currentXInfo + 'px';
      infoBox.style.top = currentYInfo + 'px';
    }
    if (isDraggingLearning) {
      e.preventDefault();
      learningBox.style.left = (e.clientX - offsetXLearning) + 'px';
      learningBox.style.top = (e.clientY - offsetYLearning) + 'px';
    }
    if (isResizingControls) {
      e.preventDefault();
      const deltaX = e.clientX - startX;
      const newWidth = Math.max(200, Math.min(800, startWidth - deltaX));
      controlsBox.style.width = newWidth + 'px';
    }
    if(isDraggingDotGraph) {
      dotGraph.style.left = (e.clientX - graphOffsetX) + 'px';
      dotGraph.style.top = (e.clientY - graphOffsetY) + 'px';
      dotGraph.style.bottom = 'auto';
    }
    if(isDraggingUnitGraph) {
      unitGraph.style.left = (e.clientX - graphOffsetX) + 'px';
      unitGraph.style.top = (e.clientY - graphOffsetY) + 'px';
      unitGraph.style.bottom = 'auto';
    }
    if(isPanningDotGraph) {
      e.preventDefault();
      const deltaX = e.clientX - graphOffsetX;
      const deltaY = e.clientY - graphOffsetY;
      dotOffsetX += deltaX;
      dotOffsetY += deltaY;
      graphOffsetX = e.clientX;
      graphOffsetY = e.clientY;
      updateDotProductGraph();
    }
    if(isPanningUnitGraph) {
      e.preventDefault();
      const deltaX = e.clientX - graphOffsetX;
      const deltaY = e.clientY - graphOffsetY;
      unitOffsetX += deltaX;
      unitOffsetY += deltaY;
      graphOffsetX = e.clientX;
      graphOffsetY = e.clientY;
      updateUnitCircleGraph();
    }
    if(isResizingDotGraph) {
      e.preventDefault();
      const deltaX = e.clientX - resizeStartX;
      const deltaY = e.clientY - resizeStartY;
      const delta = Math.max(deltaX, deltaY);
      const aspectRatio = resizeStartWidth / resizeStartHeight;
      let newHeight = Math.max(120, resizeStartHeight + delta);
      let newWidth = newHeight * aspectRatio;
      if (newWidth < 150) {
        newWidth = 150;
        newHeight = newWidth / aspectRatio;
      }
      dotGraph.style.width = newWidth + 'px';
      dotGraph.style.height = newHeight + 'px';
      updateDotProductGraph();
    }
    if(isResizingUnitGraph) {
      e.preventDefault();
      const deltaX = e.clientX - resizeStartX;
      const deltaY = e.clientY - resizeStartY;
      const delta = Math.max(deltaX, deltaY);
      let newSize = Math.max(150, resizeStartWidth + delta);
      unitGraph.style.width = newSize + 'px';
      unitGraph.style.height = newSize + 'px';
      updateUnitCircleGraph();
    }
  });

  dotGraph.addEventListener('wheel', (e) => {
    e.preventDefault();
    dotGraphScale += e.deltaY * -0.03;
    dotGraphScale = Math.min(Math.max(5, dotGraphScale), 400);
    updateDotProductGraph();
  });

  unitGraph.addEventListener('wheel', (e) => {
    e.preventDefault();
    unitGraphScale += e.deltaY * -0.15;
    unitGraphScale = Math.min(Math.max(20, unitGraphScale), 200);
    updateUnitCircleGraph();
  });

  dotGraph.addEventListener('auxclick', (e) => {
    if (e.button === 1) e.preventDefault();
  });
  
  unitGraph.addEventListener('auxclick', (e) => {
    if (e.button === 1) e.preventDefault();
  });
  
</script>
</html>