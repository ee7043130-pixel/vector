<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>„Éô„ÇØ„Éà„É´Â≠¶ÁøíVR - 3D„Éê„Éº„Ç∏„Éß„É≥</title>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/webxr/VRButton.js"></script>
<style>
  * { box-sizing: border-box; }
  body {
    margin: 0; padding: 0;
    background: #000;
    color: #fff;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    overflow: hidden;
    user-select: none;
  }
  #info {
    position: absolute;
    top: 10px;
    left: 10px;
    background: rgba(0,0,0,0.85);
    padding: 12px 18px;
    border-radius: 8px;
    width: 320px;
    font-size: 14px;
    line-height: 1.5em;
    z-index: 10;
  }
  #info h3 {
    margin: 0 0 10px 0;
    font-weight: 700;
    font-size: 20px;
  }
  .calc-row {
    margin: 6px 0;
    font-weight: 600;
    display: flex;
    justify-content: space-between;
  }
  .calc-label { color: #aaa; }
  .calc-value { color: #0cf; }

  #controls {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(0,0,0,0.85);
    padding: 15px 20px;
    border-radius: 8px;
    width: 320px;
    max-width: 95vw;
    max-height: 90vh;
    overflow-y: auto;
    z-index: 10;
  }
  #controls h4 {
    margin: 12px 0 8px 0;
    font-weight: 700;
    border-bottom: 1px solid #444;
    padding-bottom: 4px;
    display: flex;
    align-items: center;
  }
  .slider-container {
    margin-bottom: 8px;
  }
  label {
    display: flex;
    justify-content: space-between;
    font-size: 13px;
    margin-bottom: 3px;
  }
  input[type=range] {
    width: 100%;
    -webkit-appearance: none;
    height: 6px;
    border-radius: 5px;
    background: #444;
    outline: none;
    cursor: pointer;
  }
  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #09f;
    cursor: pointer;
    border: 2px solid #fff;
    transition: background 0.3s ease;
  }
  input[type=range]::-webkit-slider-thumb:hover {
    background: #06c;
  }
  input[type=range]::-moz-range-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #09f;
    cursor: pointer;
    border: 2px solid #fff;
  }
  .value { color: #0af; font-weight: 600; }
  .value.red { color: #f55; }
  .value.green { color: #5f5; }
  .value-input {
    width: 60px;
    padding: 2px 6px;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid #444;
    border-radius: 4px;
    color: #0af;
    font-weight: 600;
    font-size: 13px;
    text-align: right;
  }
  .value-input.red { color: #f55; }
  .value-input.green { color: #5f5; }
  .value-input:focus {
    outline: none;
    border-color: #09f;
    background: rgba(255, 255, 255, 0.15);
  }
  button {
    width: 100%;
    padding: 10px;
    margin-top: 8px;
    border: none;
    background: #08a;
    color: white;
    font-weight: 700;
    font-size: 14px;
    border-radius: 6px;
    cursor: pointer;
    transition: background 0.3s ease;
  }
  button:hover { background: #06a; }
  canvas { display: block; }
  
  .mode-info {
    background: rgba(255, 150, 0, 0.9);
    padding: 8px 12px;
    border-radius: 5px;
    margin: 8px 0;
    font-size: 13px;
  }
  
  .vr-info {
    background: rgba(255, 100, 100, 0.9);
    padding: 8px 12px;
    border-radius: 5px;
    margin: 8px 0;
    font-size: 12px;
  }
</style>
</head>
<body>

<div id="info">
  <h3>üßÆ 3D„Éô„ÇØ„Éà„É´Â≠¶Áøí</h3>
  <div class="calc-row">
    <span class="calc-label">A√óB (ÂÜÖÁ©ç):</span>
    <span class="calc-value" id="dotProductAB">0.00</span>
  </div>
  <div class="calc-row">
    <span class="calc-label">A√óC (ÂÜÖÁ©ç):</span>
    <span class="calc-value" id="dotProductAC">0.00</span>
  </div>
  <div class="calc-row">
    <span class="calc-label">B√óC (ÂÜÖÁ©ç):</span>
    <span class="calc-value" id="dotProductBC">0.00</span>
  </div>
  <hr style="border-color: #444; margin: 10px 0;">
  <div class="calc-row">
    <span class="calc-label">|A√óB| (Â§ñÁ©ç):</span>
    <span class="calc-value" id="crossProductAB">0.00</span>
  </div>
  <div class="calc-row">
    <span class="calc-label">|A√óC| (Â§ñÁ©ç):</span>
    <span class="calc-value" id="crossProductAC">0.00</span>
  </div>
  <div class="calc-row">
    <span class="calc-label">|B√óC| (Â§ñÁ©ç):</span>
    <span class="calc-value" id="crossProductBC">0.00</span>
  </div>
  <hr style="border-color: #444; margin: 10px 0;">
  <div class="calc-row">
    <span class="calc-label">|A|:</span>
    <span class="calc-value" id="magnitudeA">0.00</span>
  </div>
  <div class="calc-row">
    <span class="calc-label">|B|:</span>
    <span class="calc-value" id="magnitudeB">0.00</span>
  </div>
  <div class="calc-row">
    <span class="calc-label">|C|:</span>
    <span class="calc-value" id="magnitudeC">0.00</span>
  </div>
  <hr style="border-color: #444; margin: 10px 0;">
  <div class="calc-row">
    <span class="calc-label">‚à†(A,B):</span>
    <span class="calc-value" id="angleAB">0.0¬∞</span>
  </div>
  <div class="calc-row">
    <span class="calc-label">‚à†(A,C):</span>
    <span class="calc-value" id="angleAC">0.0¬∞</span>
  </div>
  <div class="calc-row">
    <span class="calc-label">‚à†(B,C):</span>
    <span class="calc-value" id="angleBC">0.0¬∞</span>
  </div>
  <div class="vr-info" id="vrInfo" style="display:none;">
      ü•Ω VR„É¢„Éº„ÉâËµ∑Âãï‰∏≠
  </div>
</div>

<div id="controls">
  <h4>
    <input type="checkbox" id="toggleVectorA" checked style="margin-right: 8px; cursor: pointer; width: 18px; height: 18px; vertical-align: middle;">
    „Éô„ÇØ„Éà„É´ A (Èùí)
  </h4>
  <div class="slider-container">
    <label>X: <input type="number" class="value-input" id="vectorAX-value" value="3.0" min="-10" max="10" step="0.1"></label>
    <input type="range" id="vectorAX" min="-10" max="10" step="0.1" value="3" />
  </div>
  <div class="slider-container">
    <label>Y: <input type="number" class="value-input" id="vectorAY-value" value="2.0" min="-10" max="10" step="0.1"></label>
    <input type="range" id="vectorAY" min="-10" max="10" step="0.1" value="2" />
  </div>
  <div class="slider-container">
    <label>Z: <input type="number" class="value-input" id="vectorAZ-value" value="1.0" min="-10" max="10" step="0.1"></label>
    <input type="range" id="vectorAZ" min="-10" max="10" step="0.1" value="1" />
  </div>

  <h4>
    <input type="checkbox" id="toggleVectorB" checked style="margin-right: 8px; cursor: pointer; width: 18px; height: 18px; vertical-align: middle;">
    „Éô„ÇØ„Éà„É´ B (Ëµ§)
  </h4>
  <div class="slider-container">
    <label>X: <input type="number" class="value-input red" id="vectorBX-value" value="2.0" min="-10" max="10" step="0.1"></label>
    <input type="range" id="vectorBX" min="-10" max="10" step="0.1" value="2" />
  </div>
  <div class="slider-container">
    <label>Y: <input type="number" class="value-input red" id="vectorBY-value" value="3.0" min="-10" max="10" step="0.1"></label>
    <input type="range" id="vectorBY" min="-10" max="10" step="0.1" value="3" />
  </div>
  <div class="slider-container">
    <label>Z: <input type="number" class="value-input red" id="vectorBZ-value" value="0.5" min="-10" max="10" step="0.1"></label>
    <input type="range" id="vectorBZ" min="-10" max="10" step="0.1" value="0.5" />
  </div>

  <h4>
    <input type="checkbox" id="toggleVectorC" checked style="margin-right: 8px; cursor: pointer; width: 18px; height: 18px; vertical-align: middle;">
    „Éô„ÇØ„Éà„É´ C (Á∑ë)
  </h4>
  <div class="slider-container">
    <label>X: <input type="number" class="value-input green" id="vectorCX-value" value="1.0" min="-10" max="10" step="0.1"></label>
    <input type="range" id="vectorCX" min="-10" max="10" step="0.1" value="1" />
  </div>
  <div class="slider-container">
    <label>Y: <input type="number" class="value-input green" id="vectorCY-value" value="1.0" min="-10" max="10" step="0.1"></label>
    <input type="range" id="vectorCY" min="-10" max="10" step="0.1" value="1" />
  </div>
  <div class="slider-container">
    <label>Z: <input type="number" class="value-input green" id="vectorCZ-value" value="3.0" min="-10" max="10" step="0.1"></label>
    <input type="range" id="vectorCZ" min="-10" max="10" step="0.1" value="3" />
  </div>

  <button id="togglePlaneBtn">üìê Âπ≥Èù¢Ë°®Á§∫ÂàáÊõø</button>
  <button id="toggleCrossBtn">‚úñÔ∏è Â§ñÁ©ç„Éô„ÇØ„Éà„É´ÂàáÊõø</button>
  <button id="resetBtn">„É™„Çª„ÉÉ„Éà</button>
  <button id="toggleGridBtn">„Ç∞„É™„ÉÉ„ÉâÂàáÊõø</button>
</div>

<script>
  let scene, camera, renderer, controls;
  let vectorAArrow, vectorBArrow, vectorCArrow;
  let vectorALabel, vectorBLabel, vectorCLabel;
  let crossProductABArrow, crossProductACArrow, crossProductBCArrow;
  let angleLabels = [];
  let angleArcs = [];
  let projectionLines = [];
  let grid, parallelogram;
  let transformControl;
  let isVRMode = false;
  
  let vecA = new THREE.Vector3(3, 2, 1);
  let vecB = new THREE.Vector3(2, 3, 0.5);
  let vecC = new THREE.Vector3(1, 1, 3);

  let controller1, controller2;
  let controllerGrip1, controllerGrip2;

  function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a15);

    camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(10, 10, 10);
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    try {
      const vrButton = VRButton.createButton(renderer);
      vrButton.style.position = 'absolute';
      vrButton.style.bottom = '20px';
      vrButton.style.left = '50%';
      vrButton.style.transform = 'translateX(-50%)';
      vrButton.style.zIndex = '999';
      document.body.appendChild(vrButton);

      renderer.xr.addEventListener('sessionstart', () => {
        isVRMode = true;
        document.getElementById('vrInfo').style.display = 'block';
      });

      renderer.xr.addEventListener('sessionend', () => {
        isVRMode = false;
        document.getElementById('vrInfo').style.display = 'none';
      });
    } catch(e) {
      console.warn('VR not available:', e);
    }

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 0, 0);
    controls.enableDamping = false;
    controls.minDistance = 3;
    controls.maxDistance = 50;
    // „Çø„Éº„Ç≤„ÉÉ„Éà„ÇíÂéüÁÇπ„Å´Âõ∫ÂÆöÔºà„Éë„É≥„Éã„É≥„Ç∞„ÇíÁÑ°ÂäπÂåñ„Åô„Çã„Åì„Å®„ÅßÁ¢∫ÂÆü„Å´Ôºâ
    controls.enablePan = true; // „Éë„É≥„ÅØÊúâÂäπ„Å†„Åå„ÄÅÂæå„ÅßÂà∂Á¥Ñ„Çí„Åã„Åë„Çã

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 10, 10);
    scene.add(directionalLight);

    setupVRControllers();
    createGrid();
    createVectorArrows();
    createCrossProductArrows();
    createProjectionLines();
    createParallelogram();
    createAngleArcs();
    createTransformControls();
    setupSliderControls();
    setupDirectArrowDragging();
    updateAllVectors();

    window.addEventListener('resize', onWindowResize);
    renderer.setAnimationLoop(animate);
  }

  function setupDirectArrowDragging() {
    renderer.domElement.addEventListener('pointerdown', (event) => {
      const mouse = new THREE.Vector2();
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);

      // Áü¢Âç∞„Å®„Éò„É´„Éë„ÉºÁêÉ„ÅÆ‰∏°Êñπ„Çí„ÉÅ„Çß„ÉÉ„ÇØ
      const arrows = [vectorAArrow, vectorBArrow, vectorCArrow];
      const helpers = arrows.map(arrow => arrow.userData.helper).filter(h => h);
      const allObjects = [...arrows, ...helpers];
      
      const intersects = raycaster.intersectObjects(allObjects, true);

      if(intersects.length > 0){
        // „ÇØ„É™„ÉÉ„ÇØ„Åï„Çå„Åü„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÁâπÂÆö
        let obj = intersects[0].object;
        let targetHelper = null;

        // „Éò„É´„Éë„ÉºÁêÉ„ÅåÁõ¥Êé•„ÇØ„É™„ÉÉ„ÇØ„Åï„Çå„ÅüÂ†¥Âêà
        if(obj.userData.isHelper){
          targetHelper = obj;
        } else {
          // Áü¢Âç∞„Åå„ÇØ„É™„ÉÉ„ÇØ„Åï„Çå„ÅüÂ†¥Âêà„ÄÅË¶™Áü¢Âç∞„ÇíÊé¢„Åó„Å¶„Åù„ÅÆ„Éò„É´„Éë„Éº„ÇíÂèñÂæó
          while(obj.parent && !obj.userData.isArrow){
            obj = obj.parent;
          }
          if(obj.userData.isArrow && obj.userData.helper){
            targetHelper = obj.userData.helper;
          }
        }

        if(targetHelper){
          controls.enabled = false;
          transformControl.attach(targetHelper);
          transformControl.visible = true;
          // „Çø„Éº„Ç≤„ÉÉ„Éà„ÇíÂéüÁÇπ„Å´Âõ∫ÂÆö
          controls.target.set(0, 0, 0);
          controls.update();
          event.stopPropagation();
        }
      } else {
        // ËÉåÊôØ„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Åü„Çâ„Éá„Çø„ÉÉ„ÉÅ
        if(!transformControl.dragging){
          transformControl.detach();
          transformControl.visible = false;
          controls.enabled = true;
          // „Çø„Éº„Ç≤„ÉÉ„Éà„ÇíÁ¢∫ÂÆü„Å´ÂéüÁÇπ„Å´Êàª„Åô
          controls.target.set(0, 0, 0);
          controls.update();
        }
      }
    });
  }

  function setupVRControllers() {
    controller1 = renderer.xr.getController(0);
    controller1.addEventListener('selectstart', onSelectStart);
    controller1.addEventListener('selectend', onSelectEnd);
    scene.add(controller1);

    controller2 = renderer.xr.getController(1);
    controller2.addEventListener('selectstart', onSelectStart);
    controller2.addEventListener('selectend', onSelectEnd);
    scene.add(controller2);

    controllerGrip1 = renderer.xr.getControllerGrip(0);
    scene.add(controllerGrip1);

    controllerGrip2 = renderer.xr.getControllerGrip(1);
    scene.add(controllerGrip2);

    const geometry = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, 0, 0),
      new THREE.Vector3(0, 0, -1)
    ]);

    const lineMaterial = new THREE.LineBasicMaterial({color: 0xffffff});
    const line1 = new THREE.Line(geometry, lineMaterial);
    line1.scale.z = 5;
    controller1.add(line1);

    const line2 = new THREE.Line(geometry.clone(), lineMaterial.clone());
    line2.scale.z = 5;
    controller2.add(line2);
  }

  function onSelectStart(event) {
    const controller = event.target;
    const tempMatrix = new THREE.Matrix4();
    tempMatrix.identity().extractRotation(controller.matrixWorld);

    const raycaster = new THREE.Raycaster();
    raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
    raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

    const arrows = [vectorAArrow, vectorBArrow, vectorCArrow];
    const intersects = raycaster.intersectObjects(arrows, true);

    if(intersects.length > 0) {
      let obj = intersects[0].object;
      while(obj.parent && !obj.userData.isArrow){
        obj = obj.parent;
      }
      if(obj.userData.isArrow){
        controller.userData.selected = obj;
        controller.userData.vectorName = obj.userData.vectorName;
      }
    }
  }

  function onSelectEnd(event) {
    const controller = event.target;
    controller.userData.selected = undefined;
    controller.userData.vectorName = undefined;
  }

  function updateVRControllers() {
    [controller1, controller2].forEach(controller => {
      if(controller.userData.selected && controller.userData.vectorName) {
        const origin = new THREE.Vector3();
        origin.setFromMatrixPosition(controller.matrixWorld);
        
        const name = controller.userData.vectorName;
        if(name === 'A'){
          vecA.copy(origin);
          updateSliderFromVector('A', vecA);
        } else if(name === 'B'){
          vecB.copy(origin);
          updateSliderFromVector('B', vecB);
        } else if(name === 'C'){
          vecC.copy(origin);
          updateSliderFromVector('C', vecC);
        }
        updateAllVectors();
      }
    });
  }

  function createGrid() {
    grid = new THREE.Group();
    
    const gridXY = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
    gridXY.rotation.x = Math.PI / 2;
    grid.add(gridXY);

    const gridXZ = new THREE.GridHelper(20, 20, 0x334444, 0x112222);
    grid.add(gridXZ);

    const gridYZ = new THREE.GridHelper(20, 20, 0x443344, 0x221122);
    gridYZ.rotation.z = Math.PI / 2;
    grid.add(gridYZ);

    const axesHelper = new THREE.AxesHelper(12);
    grid.add(axesHelper);

    const origin = new THREE.Mesh(
      new THREE.SphereGeometry(0.15, 16, 16),
      new THREE.MeshBasicMaterial({color: 0xffff00})
    );
    grid.add(origin);

    scene.add(grid);
  }

  function createArrow(color) {
    const group = new THREE.Group();
    group.userData.isArrow = true;

    const shaftGeom = new THREE.CylinderGeometry(0.06, 0.06, 1, 16);
    const shaftMat = new THREE.MeshStandardMaterial({
      color: color,
      metalness: 0.3,
      roughness: 0.6
    });
    const shaft = new THREE.Mesh(shaftGeom, shaftMat);
    shaft.position.y = 0.5;
    group.add(shaft);

    const headGeom = new THREE.ConeGeometry(0.18, 0.4, 16);
    const headMat = new THREE.MeshStandardMaterial({
      color: color,
      metalness: 0.3,
      roughness: 0.6
    });
    const head = new THREE.Mesh(headGeom, headMat);
    head.position.y = 1.2;
    group.add(head);

    return group;
  }

  function createVectorArrows() {
    vectorAArrow = createArrow(0x3366ff);
    vectorAArrow.userData.vectorName = 'A';
    scene.add(vectorAArrow);

    vectorBArrow = createArrow(0xff3366);
    vectorBArrow.userData.vectorName = 'B';
    scene.add(vectorBArrow);

    vectorCArrow = createArrow(0x33ff66);
    vectorCArrow.userData.vectorName = 'C';
    scene.add(vectorCArrow);

    vectorALabel = createLabelSprite('A', '#5588ff');
    vectorBLabel = createLabelSprite('B', '#ff5588');
    vectorCLabel = createLabelSprite('C', '#55ff88');

    scene.add(vectorALabel);
    scene.add(vectorBLabel);
    scene.add(vectorCLabel);

    // Áü¢Âç∞„ÅÆÂÖàÁ´Ø„Å´„Éâ„É©„ÉÉ„Ç∞ÂèØËÉΩ„Å™ÁêÉ„ÇíËøΩÂä†
    const helperGeom = new THREE.SphereGeometry(0.3, 16, 16);
    
    const helperA = new THREE.Mesh(helperGeom, new THREE.MeshBasicMaterial({
      color: 0x3366ff,
      transparent: true,
      opacity: 0.5
    }));
    helperA.userData.vectorName = 'A';
    helperA.userData.isHelper = true;
    scene.add(helperA);
    vectorAArrow.userData.helper = helperA;

    const helperB = new THREE.Mesh(helperGeom, new THREE.MeshBasicMaterial({
      color: 0xff3366,
      transparent: true,
      opacity: 0.5
    }));
    helperB.userData.vectorName = 'B';
    helperB.userData.isHelper = true;
    scene.add(helperB);
    vectorBArrow.userData.helper = helperB;

    const helperC = new THREE.Mesh(helperGeom, new THREE.MeshBasicMaterial({
      color: 0x33ff66,
      transparent: true,
      opacity: 0.5
    }));
    helperC.userData.vectorName = 'C';
    helperC.userData.isHelper = true;
    scene.add(helperC);
    vectorCArrow.userData.helper = helperC;
  }

  function createCrossProductArrows() {
    // A√óB (ÈªÑËâ≤)
    crossProductABArrow = createArrow(0xffff00);
    crossProductABArrow.userData.vectorName = 'A√óB';
    scene.add(crossProductABArrow);

    // A√óC („Ç∑„Ç¢„É≥)
    crossProductACArrow = createArrow(0x00ffff);
    crossProductACArrow.userData.vectorName = 'A√óC';
    scene.add(crossProductACArrow);

    // B√óC („Éû„Çº„É≥„Çø)
    crossProductBCArrow = createArrow(0xff00ff);
    crossProductBCArrow.userData.vectorName = 'B√óC';
    scene.add(crossProductBCArrow);
  }

  function createLabelSprite(text, color) {
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');
    ctx.font = 'bold 60px Arial';
    ctx.fillStyle = color;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, 64, 64);
    const texture = new THREE.CanvasTexture(canvas);
    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map: texture, transparent:true}));
    sprite.scale.set(0.8, 0.8, 1);
    return sprite;
  }

  function createAngleSprite(text, color) {
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 64;
    const ctx = canvas.getContext('2d');
    
    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
    ctx.fillRect(0, 0, 128, 64);
    
    ctx.font = 'bold 28px Arial';
    ctx.fillStyle = color;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, 64, 32);
    
    const texture = new THREE.CanvasTexture(canvas);
    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map: texture, transparent:true}));
    sprite.scale.set(0.8, 0.4, 1);
    return sprite;
  }

  function updateAngleSprite(sprite, text) {
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 64;
    const ctx = canvas.getContext('2d');
    
    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
    ctx.fillRect(0, 0, 128, 64);
    
    ctx.font = 'bold 28px Arial';
    ctx.fillStyle = '#ffff00';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, 64, 32);
    
    sprite.material.map.dispose();
    sprite.material.map = new THREE.CanvasTexture(canvas);
    sprite.material.needsUpdate = true;
  }

  function createProjectionLines() {
    const lineAB = new THREE.Line(
      new THREE.BufferGeometry(),
      new THREE.LineBasicMaterial({color: 0x00ff00, transparent:true, opacity:0.6})
    );
    scene.add(lineAB);
    projectionLines.push({line: lineAB, from: vecB, to: vecA});

    const lineAC = new THREE.Line(
      new THREE.BufferGeometry(),
      new THREE.LineBasicMaterial({color: 0x00ffff, transparent:true, opacity:0.6})
    );
    scene.add(lineAC);
    projectionLines.push({line: lineAC, from: vecC, to: vecA});
  }

  function createAngleArcs() {
    for(let i = 0; i < 3; i++){
      const arcGeometry = new THREE.BufferGeometry();
      const arcMaterial = new THREE.LineBasicMaterial({
        color: 0xffff00,
        transparent: true,
        opacity: 0.8
      });
      const arc = new THREE.Line(arcGeometry, arcMaterial);
      scene.add(arc);
      angleArcs.push(arc);
      
      const angleLabel = createAngleSprite('0¬∞', '#ffff00');
      scene.add(angleLabel);
      angleLabels.push(angleLabel);
    }
  }

  function createAngleArc(v1, v2, radius, segments = 32) {
    const angle = Math.acos(Math.max(-1, Math.min(1, v1.dot(v2) / (v1.length() * v2.length()))));
    
    if(angle < 0.01) return [];
    
    const points = [];
    const v1Norm = v1.clone().normalize();
    const v2Norm = v2.clone().normalize();
    const axis = new THREE.Vector3().crossVectors(v1Norm, v2Norm).normalize();
    
    for(let i = 0; i <= segments; i++){
      const t = i / segments;
      const currentAngle = angle * t;
      const rotatedVec = v1Norm.clone().applyAxisAngle(axis, currentAngle);
      points.push(rotatedVec.multiplyScalar(radius));
    }
    
    return points;
  }

  function createParallelogram() {
    parallelogram = new THREE.Group();
    scene.add(parallelogram);
  }

  function updateParallelogram() {
    parallelogram.children.forEach(child => {
      child.geometry.dispose();
      child.material.dispose();
    });
    parallelogram.clear();

    const origin = new THREE.Vector3(0, 0, 0);
    const pA = vecA.clone();
    const pB = vecB.clone();
    const pC = vecC.clone();
    const pAB = vecA.clone().add(vecB);
    const pAC = vecA.clone().add(vecC);
    const pBC = vecB.clone().add(vecC);
    const pABC = vecA.clone().add(vecB).add(vecC);

    parallelogram.add(createFace(origin, pA, pAB, pB, 0x6633cc));
    parallelogram.add(createFace(origin, pA, pAC, pC, 0x33cc66));
    parallelogram.add(createFace(origin, pB, pBC, pC, 0xcc6633));
    parallelogram.add(createFace(pA, pAB, pABC, pAC, 0x9966cc));
    parallelogram.add(createFace(pB, pAB, pABC, pBC, 0xcc9966));
    parallelogram.add(createFace(pC, pAC, pABC, pBC, 0x66cc99));
  }

  function createFace(v1, v2, v3, v4, color) {
    const geometry = new THREE.BufferGeometry();
    const vertices = new Float32Array([
      ...v1.toArray(), ...v2.toArray(), ...v3.toArray(),
      ...v1.toArray(), ...v3.toArray(), ...v4.toArray()
    ]);
    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
    const material = new THREE.MeshBasicMaterial({
      color: color,
      transparent: true,
      opacity: 0.25,
      side: THREE.DoubleSide
    });
    return new THREE.Mesh(geometry, material);
  }

  function updateArrow(arrow, vec) {
    const len = vec.length();
    if(len < 0.01){
      arrow.visible = false;
      return;
    }
    arrow.visible = true;
    arrow.position.set(0, 0, 0);

    const dir = vec.clone().normalize();
    const axis = new THREE.Vector3(0, 1, 0);
    const quat = new THREE.Quaternion();
    quat.setFromUnitVectors(axis, dir);
    arrow.quaternion.copy(quat);

    const shaft = arrow.children[0];
    const head = arrow.children[1];

    shaft.scale.set(1, len, 1);
    shaft.position.set(0, len / 2, 0);
    head.position.set(0, len + 0.2, 0);
    
    arrow.userData.tipPosition = vec.clone();
  }

  function updateProjectionLine(projData) {
    const {line, from, to} = projData;
    
    if(to.length() < 0.01 || from.length() < 0.01){
      line.visible = false;
      return;
    }
    line.visible = true;

    const toNorm = to.clone().normalize();
    const projLength = from.dot(toNorm);
    const projVec = toNorm.clone().multiplyScalar(projLength);

    const points = [from.clone(), projVec.clone()];
    line.geometry.setFromPoints(points);

    const dotProd = from.dot(to);
    line.material.color.set(dotProd >= 0 ? 0x00ff00 : 0xff0000);
  }

  function updateAllVectors() {
    updateArrow(vectorAArrow, vecA);
    updateArrow(vectorBArrow, vecB);
    updateArrow(vectorCArrow, vecC);

    // „Éò„É´„Éë„ÉºÁêÉ„ÅÆ‰ΩçÁΩÆ„ÇíÊõ¥Êñ∞
    if(vectorAArrow.userData.helper) vectorAArrow.userData.helper.position.copy(vecA);
    if(vectorBArrow.userData.helper) vectorBArrow.userData.helper.position.copy(vecB);
    if(vectorCArrow.userData.helper) vectorCArrow.userData.helper.position.copy(vecC);

    vectorALabel.position.copy(vecA).add(new THREE.Vector3(0.4, 0.4, 0.4));
    vectorBLabel.position.copy(vecB).add(new THREE.Vector3(0.4, 0.4, 0.4));
    vectorCLabel.position.copy(vecC).add(new THREE.Vector3(0.4, 0.4, 0.4));

    // Â§ñÁ©ç„Éô„ÇØ„Éà„É´„ÅÆË®àÁÆó„Å®Êõ¥Êñ∞
    const crossAB = new THREE.Vector3().crossVectors(vecA, vecB);
    const crossAC = new THREE.Vector3().crossVectors(vecA, vecC);
    const crossBC = new THREE.Vector3().crossVectors(vecB, vecC);
    
    updateArrow(crossProductABArrow, crossAB);
    updateArrow(crossProductACArrow, crossAC);
    updateArrow(crossProductBCArrow, crossBC);

    projectionLines[0].from = vecB;
    projectionLines[0].to = vecA;
    projectionLines[1].from = vecC;
    projectionLines[1].to = vecA;
    
    projectionLines.forEach(proj => updateProjectionLine(proj));
    updateParallelogram();
    updateAngleDisplays();
    updateCalculations();
  }

  function updateAngleDisplays() {
    const calcAngle = (v1, v2) => {
      const m1 = v1.length();
      const m2 = v2.length();
      if(m1 < 0.001 || m2 < 0.001) return 0;
      const cosAngle = v1.dot(v2) / (m1 * m2);
      return Math.acos(Math.max(-1, Math.min(1, cosAngle))) * 180 / Math.PI;
    };

    const radius = 0.5;
    const pairs = [
      {v1: vecA, v2: vecB, arc: angleArcs[0], label: angleLabels[0], radius: radius, color: 0xffff00},
      {v1: vecA, v2: vecC, arc: angleArcs[1], label: angleLabels[1], radius: radius * 0.8, color: 0x00ffff},
      {v1: vecB, v2: vecC, arc: angleArcs[2], label: angleLabels[2], radius: radius * 0.6, color: 0xff00ff}
    ];

    pairs.forEach(({v1, v2, arc, label, radius, color}) => {
      const angle = calcAngle(v1, v2);
      if(v1.length() > 0.1 && v2.length() > 0.1 && angle > 1){
        const arcPoints = createAngleArc(v1, v2, radius);
        arc.geometry.setFromPoints(arcPoints);
        arc.material.color.set(color);
        arc.visible = true;
        
        const midAngle = Math.acos(Math.max(-1, Math.min(1, v1.dot(v2) / (v1.length() * v2.length())))) / 2;
        const axis = new THREE.Vector3().crossVectors(v1.clone().normalize(), v2.clone().normalize()).normalize();
        const labelPos = v1.clone().normalize().applyAxisAngle(axis, midAngle).multiplyScalar(radius * 1.5);
        
        label.position.copy(labelPos);
        updateAngleSprite(label, `${angle.toFixed(1)}¬∞`);
        label.visible = true;
      } else {
        arc.visible = false;
        label.visible = false;
      }
    });
  }

  function updateCalculations() {
    const dotAB = vecA.dot(vecB);
    const dotAC = vecA.dot(vecC);
    const dotBC = vecB.dot(vecC);
    const magA = vecA.length();
    const magB = vecB.length();
    const magC = vecC.length();

    // Â§ñÁ©ç„ÅÆÂ§ß„Åç„Åï„ÇíË®àÁÆó
    const crossAB = new THREE.Vector3().crossVectors(vecA, vecB);
    const crossAC = new THREE.Vector3().crossVectors(vecA, vecC);
    const crossBC = new THREE.Vector3().crossVectors(vecB, vecC);
    const magCrossAB = crossAB.length();
    const magCrossAC = crossAC.length();
    const magCrossBC = crossBC.length();

    const calcAngle = (v1, v2) => {
      const m1 = v1.length();
      const m2 = v2.length();
      if(m1 < 0.001 || m2 < 0.001) return 0;
      const cosAngle = v1.dot(v2) / (m1 * m2);
      return (Math.acos(Math.max(-1, Math.min(1, cosAngle))) * 180 / Math.PI).toFixed(1);
    };

    document.getElementById('dotProductAB').textContent = dotAB.toFixed(2);
    document.getElementById('dotProductAC').textContent = dotAC.toFixed(2);
    document.getElementById('dotProductBC').textContent = dotBC.toFixed(2);
    document.getElementById('crossProductAB').textContent = magCrossAB.toFixed(2);
    document.getElementById('crossProductAC').textContent = magCrossAC.toFixed(2);
    document.getElementById('crossProductBC').textContent = magCrossBC.toFixed(2);
    document.getElementById('magnitudeA').textContent = magA.toFixed(2);
    document.getElementById('magnitudeB').textContent = magB.toFixed(2);
    document.getElementById('magnitudeC').textContent = magC.toFixed(2);
    document.getElementById('angleAB').textContent = calcAngle(vecA, vecB) + '¬∞';
    document.getElementById('angleAC').textContent = calcAngle(vecA, vecC) + '¬∞';
    document.getElementById('angleBC').textContent = calcAngle(vecB, vecC) + '¬∞';
  }

  function createTransformControls() {
    transformControl = new THREE.TransformControls(camera, renderer.domElement);
    transformControl.setMode('translate');
    transformControl.setSpace('world');
    transformControl.setSize(0.8);
    
    // „Ç´„É°„É©„Çø„Éº„Ç≤„ÉÉ„Éà„Çí‰øùÂ≠ò„Åô„ÇãÂ§âÊï∞
    let savedCameraTarget = new THREE.Vector3();
    let savedCameraPosition = new THREE.Vector3();
    
    transformControl.addEventListener('dragging-changed', (event) => {
      if(event.value) {
        // „Éâ„É©„ÉÉ„Ç∞ÈñãÂßãÊôÇÔºöOrbitControls„ÇíÁÑ°ÂäπÂåñ„Åó„ÄÅ„Ç´„É°„É©„ÅÆÁä∂ÊÖã„Çí‰øùÂ≠ò
        controls.enabled = false;
        savedCameraTarget.copy(controls.target);
        savedCameraPosition.copy(camera.position);
      } else {
        // „Éâ„É©„ÉÉ„Ç∞ÁµÇ‰∫ÜÊôÇÔºöOrbitControls„ÇíÂÜçÊúâÂäπÂåñ„Åó„ÄÅ„Çø„Éº„Ç≤„ÉÉ„Éà„ÇíÂéüÁÇπ„Å´Âõ∫ÂÆö
        controls.enabled = true;
        controls.target.set(0, 0, 0);
        controls.update();
      }
    });
    
    transformControl.addEventListener('change', () => {
      if(transformControl.object){
        // „Éò„É´„Éë„Éº„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆ‰ΩçÁΩÆ„ÇíÂèñÂæó
        const helperPos = transformControl.object.position.clone();
        const name = transformControl.object.userData.vectorName;
        
        // „Éô„ÇØ„Éà„É´„ÇíÊõ¥Êñ∞
        if(name === 'A'){
          vecA.copy(helperPos);
          updateSliderFromVector('A', vecA);
        } else if(name === 'B'){
          vecB.copy(helperPos);
          updateSliderFromVector('B', vecB);
        } else if(name === 'C'){
          vecC.copy(helperPos);
          updateSliderFromVector('C', vecC);
        }
        updateAllVectors();
        
        // „Éâ„É©„ÉÉ„Ç∞‰∏≠„ÇÇ„Çø„Éº„Ç≤„ÉÉ„Éà„ÇíÂéüÁÇπ„Å´Âõ∫ÂÆö
        controls.target.set(0, 0, 0);
      }
    });
    
    scene.add(transformControl);
    transformControl.visible = false;
  }

  function updateSliderFromVector(name, vec) {
    document.getElementById(`vector${name}X`).value = vec.x.toFixed(1);
    document.getElementById(`vector${name}Y`).value = vec.y.toFixed(1);
    document.getElementById(`vector${name}Z`).value = vec.z.toFixed(1);
    document.getElementById(`vector${name}X-value`).value = vec.x.toFixed(1);
    document.getElementById(`vector${name}Y-value`).value = vec.y.toFixed(1);
    document.getElementById(`vector${name}Z-value`).value = vec.z.toFixed(1);
  }

  function setupSliderControls() {
    const sliders = [
      {id: 'vectorAX', vec: vecA, key:'x', labelId:'vectorAX-value'},
      {id: 'vectorAY', vec: vecA, key:'y', labelId:'vectorAY-value'},
      {id: 'vectorAZ', vec: vecA, key:'z', labelId:'vectorAZ-value'},
      {id: 'vectorBX', vec: vecB, key:'x', labelId:'vectorBX-value'},
      {id: 'vectorBY', vec: vecB, key:'y', labelId:'vectorBY-value'},
      {id: 'vectorBZ', vec: vecB, key:'z', labelId:'vectorBZ-value'},
      {id: 'vectorCX', vec: vecC, key:'x', labelId:'vectorCX-value'},
      {id: 'vectorCY', vec: vecC, key:'y', labelId:'vectorCY-value'},
      {id: 'vectorCZ', vec: vecC, key:'z', labelId:'vectorCZ-value'},
    ];

    sliders.forEach(({id, vec, key, labelId}) => {
      const slider = document.getElementById(id);
      const input = document.getElementById(labelId);
      
      // „Çπ„É©„Ç§„ÉÄ„ÉºÂ§âÊõ¥ÊôÇ
      slider.addEventListener('input', () => {
        const value = parseFloat(slider.value);
        vec[key] = value;
        input.value = value.toFixed(1);
        updateAllVectors();
      });

      // Êï∞ÂÄ§ÂÖ•Âäõ„Éï„Ç£„Éº„É´„ÉâÂ§âÊõ¥ÊôÇ
      input.addEventListener('input', () => {
        let value = parseFloat(input.value);
        if(!isNaN(value)) {
          value = Math.max(-10, Math.min(10, value)); // ÁØÑÂõ≤Âà∂Èôê
          vec[key] = value;
          slider.value = value;
          updateAllVectors();
        }
      });

      // Enter„Ç≠„Éº„ÅßÁ¢∫ÂÆö
      input.addEventListener('keydown', (e) => {
        if(e.key === 'Enter') {
          input.blur();
        }
      });
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      vecA.set(3, 2, 1);
      vecB.set(2, 3, 0.5);
      vecC.set(1, 1, 3);
      sliders.forEach(({id, vec, key, labelId}) => {
        document.getElementById(id).value = vec[key];
        document.getElementById(labelId).value = vec[key].toFixed(1);
      });
      updateAllVectors();
    });

    document.getElementById('toggleGridBtn').addEventListener('click', () => {
      grid.visible = !grid.visible;
    });

    document.getElementById('togglePlaneBtn').addEventListener('click', () => {
      parallelogram.visible = !parallelogram.visible;
    });

    document.getElementById('toggleCrossBtn').addEventListener('click', () => {
      const newVisibility = !crossProductABArrow.visible;
      crossProductABArrow.visible = newVisibility;
      crossProductACArrow.visible = newVisibility;
      crossProductBCArrow.visible = newVisibility;
    });

    // „ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„Åß„Éô„ÇØ„Éà„É´„ÅÆË°®Á§∫ÂàáÊõø
    document.getElementById('toggleVectorA').addEventListener('change', (e) => {
      vectorAArrow.visible = e.target.checked;
      vectorALabel.visible = e.target.checked;
    });

    document.getElementById('toggleVectorB').addEventListener('change', (e) => {
      vectorBArrow.visible = e.target.checked;
      vectorBLabel.visible = e.target.checked;
    });

    document.getElementById('toggleVectorC').addEventListener('change', (e) => {
      vectorCArrow.visible = e.target.checked;
      vectorCLabel.visible = e.target.checked;
    });
  }

  function animate() {
    if(!isVRMode) {
      // TransformControls‰ΩøÁî®‰∏≠„Åß„Å™„ÅÑÂ†¥Âêà„ÅÆ„Åø„ÄÅ„Çø„Éº„Ç≤„ÉÉ„Éà„ÇíÂéüÁÇπ„Å´Âõ∫ÂÆö
      if(!transformControl.dragging) {
        controls.target.set(0, 0, 0);
      }
      controls.update();
    } else {
      updateVRControllers();
    }
    renderer.render(scene, camera);
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  init();
</script>

</body>
</html>